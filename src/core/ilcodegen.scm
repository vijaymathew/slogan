;; Copyright (c) 2013-2017 by Vijay Mathew Pandyalakal, All Rights Reserved.

;; Translate Slogan source code to intermediate representation, i.e Scheme.

(define-structure s-yield fn k)

(define *enforce-comma* #t)

(define (scm-slogan tokenizer)
  (let ((expr (expression/statement tokenizer)))
    (if (scm-> (tokenizer 'yield-count) 0)
        (begin (reset-yield-count! tokenizer 0)
               (scm-error "yield can be called only from a function."))
        expr)))

(define (expression/statement tokenizer #!optional (top #t))
  (if (eof-object? (tokenizer 'peek))
    (tokenizer 'next)
    (let ((v (scm-statement tokenizer)))
      (if (scm-not v) (set! v (scm-expression tokenizer)))
      (assert-semicolon tokenizer)
      v)))

(define (statement tokenizer)
  (sanitize-expression
   tokenizer
   (if (scm-eq? (tokenizer 'peek) '*semicolon*) *void*
       (declare-stmt tokenizer))))

(define scm-statement statement)

(define (highlighted-line colno)
  (if (scm-< colno 0)
      (set! colno 1))
  (with-output-to-string
    '()
    (lambda ()
      (let loop ((n 0))
	(if (scm-= n colno) (scm-display #\^)
	    (begin (scm-display #\space)
		   (loop (scm-+ n 1))))))))

(define (highlighted-error-line tokenizer #!optional token)
  (let ((curr-tok-len (current-token-length tokenizer))
        (tlen (if token
                  (string-length (if (symbol? token) (symbol->string token) token))
                  0)))
    (let loop ((line-no (tokenizer 'line)) 
               (n 1)
               (program-text (tokenizer 'program-text)))
      (if (scm-not (null? program-text))
          (if (scm-= n line-no)
              (scm-cons (scm-car program-text) (highlighted-line (tokenizer 'column)))
              (loop line-no (scm-+ n 1) (scm-cdr program-text)))
          #f))))

(define (parser-error tokenizer msg #!optional token)
  (scm-error (with-output-to-string 
           '()
           (lambda ()
             (if tokenizer
                 (begin
                   (display-all "at [line: " (tokenizer 'line)
                                ", column: " (tokenizer 'column)
                                "] " msg)
                   (scm-newline)))
             (let ((hl (highlighted-error-line tokenizer token)))
               (if hl (begin (scm-display (scm-car hl))
                             (scm-newline)
                             (scm-display (scm-cdr hl))
                             (scm-newline))))))))

(define (assert-semicolon tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*semicolon*)
            (scm-eq? token '*close-brace*)
            (eof-object? token))
        (if (scm-eq? token '*semicolon*)
            (tokenizer 'next))
        #t)))

(define (declare-compiler-fn-stmt tokenizer)
  (scm-eval (func-def-stmt-with-name tokenizer)))

(define (declare-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'declare)
      (begin (tokenizer 'next)
             (let ((name (tokenizer 'next)))
               (case name
                 ((generic) (declare-generic-stmt tokenizer))
                 ((ffi) (declare-ffi-stmt tokenizer))
                 ((syntax) (declare-syntax-stmt tokenizer))
                 ((macro) (declare-macro-stmt tokenizer))
                 ((function) (declare-compiler-fn-stmt tokenizer))
                 (else
                  (parser-error tokenizer "invalid declare type")))))
      (func-def-stmt tokenizer)))

(define (normalize-c-struct-members memtypes)
  (scm-map (lambda (m) (scm-cons (scm-cadr m) (scm-caddr m))) memtypes))

(define (c-struct-stmt tokenizer)
  (let ((struct-name (tokenizer 'next)))
    (if (scm-not (symbol? struct-name))
        (parser-error tokenizer "struct name must be a symbol" struct-name)
        (let ((memtypes (scm-expression tokenizer)))
          (if (scm-not (scm-eq? (scm-car memtypes) 'scm-list))
              (parser-error tokenizer "struct member types must be a list" memtypes)
              `(def-c-struct ',struct-name ',(normalize-c-struct-members (scm-cdr memtypes))))))))

(define (c-fn-stmt tokenizer rettype libname)
  (let ((fn-name (tokenizer 'next)))
    (if (scm-not (symbol? fn-name))
        (parser-error tokenizer "function name must be a symbol" fn-name)
        (let ((paramtypes (scm-expression tokenizer)))
          (if (scm-not (pair? paramtypes))
              (parser-error tokenizer "expected parameter list"))
          (if (scm-not (scm-eq? (scm-car paramtypes) 'scm-list))
              (parser-error tokenizer "parameter types must be a list" paramtypes)
              (let ((name fn-name))
                (if (scm-eq? (tokenizer 'peek) 'as)
                    (begin (tokenizer 'next)
                           (set! name (tokenizer 'next))
                           (if (scm-not (symbol? name))
                               (parser-error tokenizer "function local name must be a symbol" name))))
                (def-c-fn libname fn-name name (scm-cdr paramtypes) rettype)))))))
                
(define (cdef-stmt tokenizer libname)
  (let ((token (tokenizer 'next)))
    (if (scm-eq? token 'struct)
        (c-struct-stmt tokenizer)
        (c-fn-stmt tokenizer token libname))))

(define (def-ffi tokenizer libname expr)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-bracket*))
      (parser-error tokenizer "ffi definitions must be within a list")
      (let loop ((defs '()))
        (if (scm-eq? (tokenizer 'peek) '*close-bracket*)
            (begin (tokenizer 'next)
                   (scm-append expr (scm-reverse defs)))
            (let ((cdef (cdef-stmt tokenizer libname)))
              (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'def-ffi)
              (loop (scm-cons cdef defs)))))))

(define *ffi-lib-count* 0)
(define (genffisym)
  (let ((s (string-append "*ffi-" (number->string *ffi-lib-count*) "-*")))
    (set! *ffi-lib-count* (scm-+ *ffi-lib-count* 1))
    (string->symbol s)))

(define (declare-ffi-stmt tokenizer)
  (let ((libname (tokenizer 'next)))
    (if (scm-not (or (string? libname)
                 (symbol? libname)))
        (parser-error tokenizer "invalid library name" libname)
        (let ((lname (genffisym)))
          (def-ffi tokenizer lname `(begin (define ,lname (if (string? ,libname)
                                                              (ffi_open ,libname)
                                                              ,libname))))))))
(define (declare-generic-stmt tokenizer)
  (let ((name (tokenizer 'next)))
    (if (valid-identifier? name)
        (define-generic-method name tokenizer)
        (parser-error tokenizer "expected a valid generic name"))))

(define (define-generic-method name tokenizer)
  (check-if-reserved-name name tokenizer)
  (let ((params '(*self* #!rest *args*)))
    `(set! ,name
       (let ((*old-name* ,name))
         (lambda ,params
           (if (procedure? *self*)
               (with-exception-catcher
                (lambda (e)
                  (if (or (wrong-number-of-arguments-exception? e)
                          (nonprocedure-operator-exception? e))
                      (scm-apply *old-name* *self* *args*)
                      (scm-raise e)))
                (lambda ()
                  (scm-apply (*self* ',name) *args*)))
               (scm-apply *old-name* *self* *args*)))))))
                
(define (func-contract-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? 'where token)
           (tokenizer 'next)
           (let ((precond (scm-expression tokenizer)))
             (if (scm-eq? (tokenizer 'peek) '*inserter*)
                 (begin
                   (tokenizer 'next)
                   (scm-cons precond (scm-expression tokenizer)))
                 (scm-cons precond #f))))
          (else #f))))

(define *func-contracts-disabled* #f)

(define (disable_function_contracts)
  (set! *func-contracts-disabled* #t))

(define (enable_function_contracts)
  (set! *func-contracts-disabled* #f))

(define (prepare-func-body-for-if body)
  (if (and (pair? body) (scm-eq? 'begin (scm-car body)))
      `(let () ,@(scm-cdr body))
      body))

(define (merge-func-contract name body-expr contract-expr)
  (if (scm-not contract-expr)
      body-expr
      (let ((body-expr (prepare-func-body-for-if body-expr))
            (pre-cond (scm-car contract-expr))
            (post-cond (scm-cdr contract-expr)))
        (if post-cond
            `(if (or *func-contracts-disabled* ,pre-cond)
                 (let ((% ,body-expr))
                   (if (or *func-contracts-disabled* ,post-cond)
                       %
                       (scm-error 'postcondition_failed ',name ',post-cond)))
                 (scm-error 'precondition_failed ',name ',pre-cond))
            `(if (or *func-contracts-disabled* ,pre-cond)
                 ,body-expr
                 (scm-error 'precondition_failed ',name ',pre-cond))))))

(define (types->typepredics types)
  (if (null? types) #f
      (let loop ((types types) (predics '()))
        (if (null? types)
            (scm-reverse predics)
            (let ((t (scm-car types)))
              (if (scm-eq? t '_) #f
                  (loop (scm-cdr types)
                        (scm-cons (string->symbol
                                   (string-append "is_" (symbol->string t)))
                                  predics))))))))

(define (insert-kw-param-names params offset)
  (if (scm-not offset)
      params
      (let loop ((params params) (i 0)
                 (insert? #f) (nparams '()))
        (cond ((null? params)
               (scm-reverse nparams))
              (insert?
               (let ((p (scm-car params)))
                 (loop (scm-cdr params) i insert?
                       (scm-cons p (scm-cons (string->keyword (symbol->string p)) nparams)))))
              (else
               (if (scm-= i offset)
                   (loop params i #t nparams)
                   (loop (scm-cdr params) (scm-+ i 1) insert?
                         (scm-cons (scm-car params) nparams))))))))

(define *scm-directives* '(#!optional #!key #!rest))

(define (normalize-params params args?)
  (let loop ((params params) (key-seen-at #f)
             (idx 0) (norms '()))
    (if (null? params)
        (insert-kw-param-names (scm-reverse norms) key-seen-at)
        (let ((p (scm-car params)))
          (cond ((scm-memq p *scm-directives*)
                 (if (and args? (eq? p '#!key))
                     (loop (scm-cdr params) idx idx norms)
                     (loop (scm-cdr params) key-seen-at idx  norms)))
                ((pair? p)
                 (loop (scm-cdr params) key-seen-at (scm-+ idx 1) (scm-cons (scm-car p) norms)))
                (else
                 (loop (scm-cdr params) key-seen-at (scm-+ idx 1) (scm-cons p norms))))))))

(define (typepredics-check predics params)
  (let loop ((predics predics) (params (normalize-params params #f))
             (checks '()))
    (if (null? predics)
        `(and ,@(scm-reverse checks))
        (loop (scm-cdr predics) (scm-cdr params)
              (scm-cons (scm-list (scm-car predics) (scm-car params))
                        checks)))))

(define (merge-method-prefix predics params-types func-body)
  (if predics
      `(if ,(typepredics-check predics (scm-car params-types))
           ,func-body
           ,(scm-append (scm-list '*old-func*) (normalize-params (scm-car params-types) #t)))
      func-body))

(define (func-def-stmt-with-name tokenizer)
  (let ((name (tokenizer 'peek)))
    (let ((has-name? (scm-not (scm-eq? name '*open-paren*))))
      (if has-name?
          (begin
            (check-if-reserved-name name tokenizer)
            (tokenizer 'next)))
      (let* ((params-types (func-params-expr tokenizer #t))
             (params (scm-car params-types))
             (contract-expr (func-contract-expr tokenizer))
             (predics (types->typepredics (scm-cdr params-types)))
             (body-expr (merge-method-prefix
                         predics params-types
                         (merge-func-contract
                          name (func-body-expr tokenizer params) contract-expr)))
             (fexpr (merge-lambda tokenizer params body-expr)))
        (if has-name?
            (if predics
                `(set! ,name (let ((*old-func* ,name)) ,fexpr))
                `(define ,name ,fexpr))
            fexpr)))))

(define (func-def-stmt tokenizer)
  (cond ((scm-eq? 'function (tokenizer 'peek))
         (tokenizer 'next)
	 (func-def-stmt-with-name tokenizer))
	((scm-eq? '*fn* (tokenizer 'peek))
	 (func-def-expr tokenizer))
        (else (break-stmt tokenizer))))

(define (break-stmt tokenizer)
  (cond ((eq? 'break (tokenizer 'peek))
         (tokenizer 'next)
         (cond ((eq? '*open-paren* (tokenizer 'peek))
                (tokenizer 'next)
                (let ((expr (if (eq? '*close-paren* (tokenizer 'peek))
                                #f
                                (scm-expression tokenizer))))
                  (if (scm-not (eq? '*close-paren* (tokenizer 'next)))
                      (parser-error tokenizer "expected closing parenthesis"))
                  `(break ,expr)))
               (else '(break #f))))
        (else (continue-stmt tokenizer))))

(define (continue-stmt tokenizer)
  (cond ((eq? 'continue (tokenizer 'peek))
         (tokenizer 'next)
         (cond ((eq? '*open-paren* (tokenizer 'peek))
                (tokenizer 'next)
                (let ((expr (if (eq? '*close-paren* (tokenizer 'peek))
                                #f
                                (scm-expression tokenizer))))
                  (if (scm-not (eq? '*close-paren* (tokenizer 'next)))
                      (parser-error tokenizer "expected closing parenthesis"))
                  `(continue ,expr)))
               (else '(continue #f))))
        (else (record-def-stmt tokenizer))))

(define (mk-predic-name psym)
  (if (scm-eq? psym '_)
      'is_object
      (string->symbol 
       (string-append 
        "is_" 
        (symbol->string psym)))))

(define (params->args params)
  (let loop ((params params)
             (args '()))
    (if (null? params)
        (scm-reverse args)
        (cond ((pair? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-caar params) args)))
              ((symbol? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-car params) args)))
              (else (loop (scm-cdr params) args))))))

(define (types-has-rest? types)
  (scm-member '@rest types))

(define (assignment-stmt tokenizer)
  (if (symbol? (tokenizer 'peek))
    (let ((sym (tokenizer 'next)))
      (if (scm-eq? sym 'let)
        (let ((n (tokenizer 'peek)))
          (if (symbol? n)
            (if (scm-eq? '*open-paren* n)
              (begin
                (tokenizer 'put sym)
                (let-expr tokenizer))
              (define-stmt tokenizer))))
        (cond
         ((scm-not (valid-identifier? sym))
          (tokenizer 'put sym)
          #f)
         ((scm-eq? (tokenizer 'peek) '*assignment*)
          (var-def-set sym tokenizer #f))
         (else
          (tokenizer 'put sym) 
          #f))))
    #f))

(define (vars-defs-set syms exprs def)
  (if (scm-not (scm-= (scm-length syms) (scm-length exprs)))
      (scm-error "not enough values or variables" syms exprs))
  (let loop ((syms syms) (exprs exprs) (defexprs '()))
    (if (scm-not (null? syms))
        (let ((sym (scm-car syms)))
          (let ((defexpr
                  (if (rvar? sym)
                      (let ((sym (normalize-rvar sym)))
                        (if def
                            `(begin
                               (define ,sym (scm-rvar))
                               (scm-rbind ,sym ,(scm-car exprs)))
                            (scm-list 'scm-rbind sym (scm-car exprs))))
                      (scm-list (if def 'define 'set!) sym (scm-car exprs)))))
            (loop (scm-cdr syms) (scm-cdr exprs) (scm-cons defexpr defexprs))))
        (scm-append '(begin) (scm-reverse defexprs)))))

(define (def-vars-list tokenizer)
  (let loop ((token (tokenizer 'peek))
             (names '()))
    (cond ((scm-eq? token '*assignment*)
           (scm-reverse names))
          ((scm-eq? token '*comma*)
           (tokenizer 'next)
           (loop (tokenizer 'peek) names))
          ((symbol? token)
           (check-if-reserved-name token tokenizer)
           (tokenizer 'next)
           (loop (tokenizer 'peek) (scm-cons token names)))
          (else
           (parser-error tokenizer "invalid variable name")))))

(define (def-exprs-list tokenizer)
  (let loop ((e (scm-expression tokenizer))
             (exprs '()))
    (let ((token (tokenizer 'peek)))
      (cond ((scm-eq? token '*comma*)
             (tokenizer 'next)
             (loop (scm-expression tokenizer)
                   (scm-cons e exprs)))
            (else (scm-reverse (scm-cons e exprs)))))))

(define (core-name-warn! name)
  (cond
   ((eq? name 'core)
    (scm-display "warning: definition will shadow core module")
    (scm-newline))
   ((core-name? name)
    (scm-display "warning: redefining ")
    (scm-display name)
    (scm-display " from core module")
    (scm-newline))))

(define (make-pattern-defines bindings)
  (scm-append '(begin) (scm-map (lambda (def) (scm-append '(define) def)) bindings)))

(define (define-stmt tokenizer)
  (let ((token (tokenizer 'next)))
    (cond
     ((symbol? token)
      (cond
       ((slgn-is_special_token token)
        (tokenizer 'put token)
        (let ((bindings (let-pattern-bindings tokenizer)))
          (make-pattern-defines bindings)))
       (else
        (check-if-reserved-name token tokenizer)
        (core-name-warn! token)
        (cond
         ((scm-eq? (tokenizer 'peek) '*colon*)
          (tokenizer 'put token)
          (let ((bindings (let-pattern-bindings tokenizer)))
            (make-pattern-defines bindings)))
         (else
          (cond
           ((scm-eq? '*assignment* (tokenizer 'peek))
            (var-def-set token tokenizer #t))
           ((scm-eq? '*comma* (tokenizer 'peek))
            (tokenizer 'next)
            (let ((vars (scm-append (scm-list token) (def-vars-list tokenizer))))
              (if (scm-eq? '*assignment* (tokenizer 'next))
                  (let ((exprs (def-exprs-list tokenizer)))
                    (vars-defs-set vars exprs #t))
                  (parser-error tokenizer "expected assignment"))))
           ((scm-eq? '*open-paren* (tokenizer 'peek))
            (tokenizer 'put token)
            (named-let-expr 'let tokenizer))
           (else
            (parser-error tokenizer "invalid let expression"))))))))
     (else
      (parser-error tokenizer "not a valid variable name")))))

(define (normalize-rvar sym)
  (let ((s (symbol->string sym)))
    (string->symbol (scm-substring s 1 (string-length s)))))

(define (rvar? sym)
  (if (symbol? sym) 
      (let ((s (symbol->string sym)))
        (and (scm-> (string-length s) 0)
             (char=? #\? (string-ref s 0))))
      #f))

(define (dynamic-var? s)
  (and (symbol? s)
       (let* ((str (symbol->string s))
              (len (string-length str)))
         (and (scm-> len 1)
              (char=? (string-ref str 0) #\%)
              (char=? (string-ref str (scm-- len 1)) #\%)))))

(define (special-var-access expr tokenizer)
  (cond
   ((dynamic-var? expr)
    `(let ((*dbinding* (task-binding (current-thread) ',expr)))
       (if (eq? *void* *dbinding*)
           ,expr
           *dbinding*)))
   ((syntax-var? expr)
    (if (tokenizer 'syntax-mode?)
        `(,expr)
        expr))
   (else expr)))

(define (var-def-set sym tokenizer def)
  (if (scm-eq? (tokenizer 'peek) '*assignment*)
      (begin (tokenizer 'next)
             (if (rvar? sym)
                 (let ((sym (normalize-rvar sym)))
                   (if def
                       `(begin
                          (define ,sym (scm-rvar))
                          (scm-rbind ,sym ,(scm-expression tokenizer)))
                       (scm-list 'scm-rbind sym (scm-expression tokenizer))))
                 (scm-list (if def 'define 'set!) sym (scm-expression tokenizer))))
      (parser-error tokenizer "expected assignment")))

(define (deref-expr tokenizer obj)
  (tokenizer 'next)
  (invoke-access-expression
   tokenizer
   (let ((s (tokenizer 'next)))
     (if (scm-not (valid-identifier? s))
         (parser-error tokenizer "invalid identifier"))
     `(let ((*obj* ,obj))
        (scm-hashtable_at
         (if (namespace? *obj*)
             (namespace-defs *obj*)
             *obj*)
         ,(scm-list 'quote s))))))

(define (invoke-access-expression tokenizer expr)
  (let loop ((expr expr))
    (let ((tok (tokenizer 'peek)))
      (cond ((scm-eq? tok '*period*)
             (member-access/funcall-expr expr tokenizer))
            ((scm-eq? tok '*open-paren*)
             (loop (func-call-expr expr tokenizer)))
            ((scm-eq? tok '*colon*)
             (pair-literal tokenizer expr))
            ((scm-eq? tok '*open-bracket*)
             (array-access-expr tokenizer expr))
            ((scm-eq? tok '*ns-deref*)
             (deref-expr tokenizer expr))
            ((scm-eq? tok '*task-send*)
             (task-send-expr tokenizer expr))
            (else expr)))))

(define (scm-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) '*semicolon*)
      *void*
      (sanitize-expression
       tokenizer
       (invoke-access-expression tokenizer (logical-or-expr tokenizer)))))

(define array-access-expr-err "invalid index access expression, expected closing bracket. (missing semicolon before list literal?)")

(define (array-access-expr tokenizer expr)
  (invoke-access-expression
   tokenizer
   (let loop ((expr expr))
     (cond ((scm-eq? (tokenizer 'peek) '*open-bracket*)
            (tokenizer 'next)
            (loop
             (cond ((scm-eq? '*colon* (tokenizer 'peek))
                    (tokenizer 'next)
                    (cond ((scm-eq? (tokenizer 'peek) '*close-bracket*)
                           (tokenizer 'next)
                           `(let ((*expr* ,expr))
                              (*-@-* *expr* (scm-cons 0 (generic-array-length *expr*)))))
                          (else
                           (let ((e `(*-@-* ,expr (scm-cons 0 ,(scm-expression tokenizer)))))
                             (if (scm-eq? (tokenizer 'next) '*close-bracket*)
                                 e
                                 (parser-error tokenizer array-access-expr-err))))))
                   (else
                    (let ((idx-expr (scm-expression tokenizer)))
                      (if (scm-eq? (tokenizer 'next) '*close-bracket*)
                          (cond ((scm-eq? (tokenizer 'peek) '*assignment*)
                                 (tokenizer 'next)
                                 `(*-@-* ,expr ,idx-expr ,(scm-expression tokenizer)))
                                (else
                                 `(*-@-* ,expr ,idx-expr)))
                          (parser-error tokenizer array-access-expr-err)))))))
           (else expr)))))

(define (pair-literal tokenizer expr)
  (tokenizer 'next)
  (let ((tail-expr (if (scm-eq? (tokenizer 'peek) '*close-bracket*)
                       '*void*
                       (scm-expression tokenizer))))
    `(scm-cons ,expr ,tail-expr)))

(define (then-expr tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
      (parser-error tokenizer "expected closing parenthesis"))
  (func-body-expr tokenizer #f #t))

(define (if-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'if)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "expected opening parenthesis"))
         (let ((expr (scm-cons 'if (scm-list (scm-expression tokenizer)
                                     (then-expr tokenizer)))))
           (if (scm-eq? (tokenizer 'peek) 'else)
               (begin (tokenizer 'next)
                      (if (scm-eq? (tokenizer 'peek) 'if)
                          (scm-append expr (scm-list (if-expr tokenizer)))
                          (scm-append expr (scm-list (func-body-expr tokenizer #f #t)))))
               (scm-append expr '(#f)))))
        (else (when-expr tokenizer))))

(define (when-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'when)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "expected opening parenthesis"))
         (let ((expr (scm-cons 'if (scm-list (scm-expression tokenizer)
                                     (then-expr tokenizer)))))
           (scm-append expr '(#f))))
        (else (case-expr tokenizer))))

(define (case-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'case)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "missing opening parenthesis before case clause"))
         (let ((value (scm-expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "missing closing parenthesis after case clause"))
           (let loop ((token (tokenizer 'peek)) (last-expr #f) (body '()))
             (if last-expr (scm-append `(case ,value) (scm-reverse body))
                 (let ((expr (normalize-sym (case-pattern-expression tokenizer))))
                   (if (scm-not (scm-eq? (tokenizer 'peek) '*inserter*))
                       (parser-error tokenizer "missing -> after case expression")
                       (tokenizer 'next))
                   (let ((result (func-body-expr tokenizer #f #t))
                         (next (tokenizer 'peek)) (le #f))
                     (if (scm-eq? next '*pipe*)
                         (tokenizer 'next)
                         (set! le #t))
                     (loop (tokenizer 'peek) le
                           (if (and le (scm-not (scm-eq? expr 'else)))
                               (scm-cons '(else #f) (scm-cons (scm-list (if (list? expr) expr (scm-cons expr '())) result) body))
                               (scm-cons (scm-list (if (or (list? expr) (scm-eq? expr 'else)) expr (scm-cons expr '()))
                                                   result) body)))))))))
        (else (match-expr tokenizer))))

(define (case-pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (scm-expression tokenizer)))

(define (pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (begin
	(tokenizer 'pattern-mode-on)
	(let ((expr (scm-expression tokenizer)))
	  (tokenizer 'pattern-mode-off)
	  expr))))

(define (unbound? r) (scm-eq? r '*unbound*))

(define (match-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'match)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "missing opening parenthesis before match clause"))
         (let ((value (scm-expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "missing closing parenthesis after match clause"))
           (match-body-expr value tokenizer)))
        (else (try-catch-expr tokenizer))))

(define (match-patterns&guards tokenizer)
  (let loop ((patterns '()) (guards '()))
    (let ((pattern (pattern-expression tokenizer))
          (guard #t))
      (if (scm-eq? (tokenizer 'peek) 'where)
          (begin (tokenizer 'next)
                 (set! guard (scm-expression tokenizer))))
      (let ((token (tokenizer 'peek)))
        (cond ((scm-eq? token '*pipe*)
               (tokenizer 'next)
               (loop (scm-cons pattern patterns)
                     (scm-cons guard guards)))
              ((scm-eq? token '*inserter*)
               (tokenizer 'next)
               (scm-cons (scm-reverse (scm-cons pattern patterns))
                         (scm-reverse (scm-cons guard guards))))
              (else
               (parser-error tokenizer "missing -> after match pattern")))))))

(define (mk-match-body patterns&guards consequent prev-pattern body)
  (let loop ((patterns (scm-car patterns&guards))
             (guards (scm-cdr patterns&guards))
             (body body))
    (if (null? patterns)
        body
        (let ((pattern (scm-car patterns))
              (guard (scm-car guards)))
          (let ((c (if (scm-eq? guard #t)
                       consequent
                       `(if ,guard
                            ,consequent
                            (begin (set! *match-found* #f)
                                   (set! *value* *orig-value*)
                                   '*unbound*)))))
            (loop (scm-cdr patterns) (scm-cdr guards)
                  (scm-cons (match-pattern (if (scm-eq? pattern '%) prev-pattern pattern) c) body)))))))

(define (last-pattern patterns&guards)
  (scm-car (scm-reverse (scm-car patterns&guards))))

(define (match-body-expr value tokenizer)
  (let loop ((token (tokenizer 'peek)) (prev-pattern #f) (last-expr #f) (body '()))
    (if last-expr `(let ((*match-expr* ,value))
                     (let ((*value* *match-expr*)
                           (*orig-value* *match-expr*)
                           (*match-found* #f)
                           (*result* '*unbound*))
                       ,@(scm-reverse body)
                       (if (unbound? *result*)
                           (scm-error 'no_match_found *match-expr*)
                           *result*)))
        (let* ((patterns&guards (match-patterns&guards tokenizer))
               (pattern (last-pattern patterns&guards))
               (consequent (func-body-expr tokenizer #f #t)))
          (let ((next (tokenizer 'peek))
                (le (scm-eq? pattern 'else)))
            (if (scm-eq? next '*pipe*)
                (if (scm-not le) (tokenizer 'next))
                (if (scm-not le) (set! le #t)))
            (loop (tokenizer 'peek)
                  (if (scm-eq? pattern '@) prev-pattern pattern)
                  le (mk-match-body patterns&guards consequent prev-pattern body)))))))

(define (try-catch-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((or (scm-eq? token 'try)
               (scm-eq? token 'trycc))
           (tokenizer 'next)
           (let ((try-expr (stmt-or-expr tokenizer)))
             (case (tokenizer 'peek)
               ((catch)
                (let* ((args (catch-args tokenizer))
                       (ex (scm-car args)))
                  (make-try-catch-expr token try-expr args
                                       `(let ((,ex (parse-exception ,ex))) ,(func-body-expr tokenizer args))
                                       (finally-expr tokenizer))))
               ((finally)
                (make-try-catch-expr token try-expr '(*e*) '(scm-raise *e*)
                                     (finally-expr tokenizer)))
               (else (parser-error tokenizer "expected catch or finally clauses")))))
          (else (yield-expr tokenizer)))))

(define (catch-args tokenizer)
  (tokenizer 'next)
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-paren*))
      (parser-error tokenizer "missing opening parenthesis"))
  (tokenizer 'next)
  (let ((result (tokenizer 'next)))
    (if (scm-not (and (symbol? result)
		  (check-if-reserved-name result tokenizer)))
        (parser-error tokenizer "invalid exception variable"))
    (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
        (parser-error tokenizer "missing closing parenthesis"))
    (tokenizer 'next)
    (scm-list result)))

(define (finally-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'finally)
         (tokenizer 'next)
         (stmt-or-expr tokenizer))
        (else *void*)))
      
(define (get-exception-handler-fnname try-token)
  (if (scm-eq? try-token 'try) 'with-exception-catcher 'with-exception-handler))

(define (make-try-catch-expr try-token try-expr catch-args catch-expr finally-expr)
  (let ((try-expr (scm-list (get-exception-handler-fnname try-token)
			(scm-list 'lambda catch-args catch-expr)
			(scm-list 'lambda (scm-list) try-expr))))
    (if (void? finally-expr)
        try-expr
        `(let ((*finally* (lambda () ,finally-expr)))
           (let ((*try-expr-value*
                  (,(get-exception-handler-fnname try-token)
                   (lambda (*exception*)
                     (begin (*finally*)
                            (scm-raise *exception*)))
                   (lambda () ,try-expr))))
             (*finally*)
             *try-expr-value*)))))

(define (yield-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token 'yield)
           (tokenizer 'next)
           (tokenizer 'yield-count-up)
           (let ((expr (scm-expression tokenizer)))
             `(call/cc (lambda(*yield*)
                         (let ((*r* (s-yield-k *yield-obj*)))
                           (s-yield-fn-set! *yield-obj* *yield*)
                           (*r* (scm-cons ,expr *yield-obj*)))))))
           (else (assert-stmt tokenizer)))))

(define (valid-identifier-exlcude-syntax? sym)
  (and (symbol? sym)
       (scm-not (or (reserved-name? sym)
                    (slgn-is_special_token sym)))))

(define (syntax-call-expr tokenizer)
  (let ((name (tokenizer 'peek)))
    (if (valid-identifier-exlcude-syntax? name)
        (let ((tokens (fetch-syntax name)))
          (if tokens
              (parse-syntax-call-expr name tokens tokenizer)
              (let ((tokens-fn (fetch-macro name)))
                (if tokens-fn
                    (parse-macro-call-expr tokens-fn tokenizer)
                    #f))))
        #f)))

(define *assertions-enabled* #t)
(define (enable_asserts) (set! *assertions-enabled* #t))
(define (disable_asserts) (set! *assertions-enabled* #f))

(define (assert-stmt tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token 'assert)
           (tokenizer 'next)
           (let ((line (tokenizer 'line))
                 (expr (scm-expression tokenizer)))
             (let ((msg (if (scm-eq? '*comma* (tokenizer 'peek))
                            (begin (tokenizer 'next)
                                   (scm-expression tokenizer))
                            #f)))
               `(if *assertions-enabled*
                    (if (scm-not ,expr)
                        (if ,msg
                            (scm-error ,msg)
                            (scm-error (quote assertion_failed)
                                   ,(string-append "line: " (number->string line)))))
                    #t))))
          (else (syntax-call-expr tokenizer)))))

(define (normalize-sym s)
  (if (and (list? s) (scm-eq? (scm-car s) 'quote))
      (scm-cadr s)
      s))

(define (assert-defs-in-block tokenizer expr)
  (if (scm-not (pair? expr)) expr
      (let ((type (scm-car expr)))
        (let loop ((body (case type
                           ((begin) (scm-cdr expr))
                           ((let) (scm-cddr expr))
                           (else expr)))
                   (exprs? #f))
          (if (null? body) #t
              (let ((e (scm-car body)))
                (if (pair? e)
                    (let ((h (scm-car e)))
                      (if (or (eq? h 'define) (eq? h 'begin)
                              (eq? h 'define-structure))
                          (if exprs?
                              (parser-error tokenizer "ill-placed definition, must come before expressions in the block")
                              (loop (scm-cdr body) #f))
                          (loop (scm-cdr body) #t))))))))))

(define (make-rewrote-def def)
  `(define ,(scm-cadr def) #f))

(define (make-rewrote-assign def)
  `(set! ,(scm-cadr def) ,(scm-caddr def)))

(define (move-up-defs-in-block expr)
  (if (scm-not (pair? expr)) expr
      (let ((type (scm-car expr)))
        (let ((rewrote-expr
               (let loop ((body (case type
                                  ((begin) (scm-cdr expr))
                                  ((let) (scm-cddr expr))
                                  (else expr)))
                          (defs '()) (exprs '()))
                 (if (null? body)
                     (scm-append (scm-reverse defs) (scm-reverse exprs))
                     (let ((e (scm-car body)))
                       (cond
                        ((pair? e)
                         (let ((f (scm-car e)))
                           (cond
                            ((eq? f 'define)
                             (loop (scm-cdr body) (scm-cons (make-rewrote-def e) defs)
                                   (scm-cons (make-rewrote-assign e) exprs)))
                            ((eq? f 'define-structure)
                             (loop (scm-cdr body) (scm-cons e defs) exprs))
                            ((eq? f 'begin)
                             (loop (scm-append (scm-cdr e) (scm-cdr body)) defs exprs))
                            (else
                             (loop (scm-cdr body) defs (scm-cons e exprs))))))
                        (else (loop (scm-cdr body) defs (scm-cons e exprs)))))))))
          (case type
            ((begin) `(begin ,@rewrote-expr))
            ((let) `(let () ,@rewrote-expr))
            (else rewrote-expr))))))

(define (block-expr tokenizer #!optional (use-let #f))
  (let ((expr
         (move-up-defs-in-block
          (if (scm-not (scm-eq? (tokenizer 'peek) '*open-brace*))
              (parser-error tokenizer "missing block start")
              (begin (tokenizer 'next)
                     (let loop ((expr (if use-let (scm-cons 'let (scm-cons '() '())) (scm-cons 'begin '())))
                                (count 0))
                       (let ((token (tokenizer 'peek)))
                         (cond ((scm-eq? token '*close-brace*)
                                (tokenizer 'next)
                                (if (zero? count) (scm-append expr (scm-list *void*)) expr))
                               ((eof-object? token)
                                (parser-error tokenizer "unexpected end of input. missing closing brace?"))
                               (else
                                (loop (scm-append expr (scm-list (expression/statement tokenizer #f)))
                                      (scm-+ 1 count)))))))))))
    (assert-defs-in-block tokenizer expr)
    expr))

(define (cmpr-expr tokenizer)
  (let loop ((fst-expr #f)
             (expr (addsub-expr tokenizer)))
    (if (cmpr-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*equals*) (loop #t (swap-operands (scm-append (eq-expr tokenizer) (scm-list expr)))))
          ((*not-equals*) (loop #t (swap-operands (scm-append (not-eq-expr tokenizer) (scm-list expr)))))	
          ((*less-than*) (loop #t (swap-operands (scm-append (lt-expr tokenizer) (scm-list expr)))))
          ((*greater-than*) (loop #t (swap-operands (scm-append (gt-expr tokenizer) (scm-list expr)))))
          ((*less-than-equals*) (loop #t (swap-operands (scm-append (lteq-expr tokenizer) (scm-list expr)))))
          ((*greater-than-equals*) (loop #t (swap-operands (scm-append (gteq-expr tokenizer) (scm-list expr))))))
        expr)))

(define (logical-or-expr tokenizer)
  (let loop ((expr (logical-and-expr tokenizer)))
    (if (scm-eq? '*or* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (or-expr tokenizer) (scm-list expr)))))
        expr)))

(define (logical-and-expr tokenizer)
  (let loop ((expr (cmpr-expr tokenizer)))
    (if (scm-eq? '*and* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (and-expr tokenizer) (scm-list expr)))))
        expr)))
  
(define (addsub-expr tokenizer)
  (let loop ((expr (term-expr tokenizer)))
    (if (add-sub-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*plus*) (loop (swap-operands (scm-append (add-expr tokenizer) (scm-list expr)))))
          ((*minus*) (loop (swap-operands (scm-append (sub-expr tokenizer) (scm-list expr))))))
        expr)))

(define (factor-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (scm-eq? token '*open-paren*)
        (begin (tokenizer 'next)
               (let ((expr (scm-expression tokenizer)))
                 (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
                     (begin (parser-error tokenizer "missing closing parenthesis")
                            #f)
                     (begin (tokenizer 'next)
                            (member-access/funcall-expr expr tokenizer)))))
        (let ((expr (if-expr tokenizer)))
          (if expr expr
              (let-expr tokenizer))))))

(define (handle-rvar-access sym)
  (if (rvar? sym)
      (scm-list 'scm-rget (normalize-rvar sym))
      sym))

(define (token->neg-number token)
  (if (number? token)
      (scm-- token)
      (scm-list 'scm-- token)))

(define (task-send-expr tokenizer task-expr)
  (tokenizer 'next)
  `(let ((*msg* ,(scm-expression tokenizer)))
     (thread-send ,task-expr *msg*)
     *msg*))

(define (literal-expr tokenizer)
  (let ((expr (func-def-expr tokenizer)))
    (if expr
        (member-access/funcall-expr expr tokenizer)
        (let ((token (tokenizer 'peek)))
          (cond ((or (number? token)
                     (string? token)
		     (char? token))
                 (slgn-repr->scm-repr (tokenizer 'next)))
                ((add-sub-opr? token)
                 (tokenizer 'next)
                 (let ((sub (scm-eq? token '*minus*))
                       (next (tokenizer 'peek)))
                   (if sub
                       (if (or (number? next) 
                               (valid-identifier? next))
                           (begin (tokenizer 'next)
                                  (token->neg-number next))
                           (scm-list '- (scm-expression tokenizer)))
                       (scm-expression tokenizer))))                       
                ((valid-identifier? token) (handle-symbol token tokenizer))
                ((scm-eq? token '*open-bracket*)
                 (list-literal tokenizer))
                ((scm-eq? token '*open-brace*)
                 (block-expr tokenizer #t))
                ((scm-eq? token '*hash*)
                 (array-or-table-literal tokenizer))
                ((scm-eq? token '*task*)
                 (tokenizer 'next)
                 `(thread-start! (make-thread (lambda () ,(func-body-expr tokenizer '())))))
                ((scm-eq? token '*task-recv*)
                 (tokenizer 'next)
                 `(thread-receive))
                ((scm-eq? token '*delay*)
                 (tokenizer 'next)
                 (scm-list 'delay (func-body-expr tokenizer #f)))
                ((scm-eq? token '*quote*)
                 (tokenizer 'next)
                 (let ((sym (tokenizer 'peek)))
                   (cond ((scm-not (symbol? sym))
                          (parser-error tokenizer "expected a symbol literal"))
                         ((slgn-is_special_token sym)
                          (parser-error tokenizer "invalid symbol literal"))
                         (else
                          (tokenizer 'next)
                          (scm-list 'quote sym)))))
		((symbol? token) (handle-symbol token tokenizer))
                (else (parser-error tokenizer "invalid literal expression")))))))

(define (handle-symbol token tokenizer)
  (cond ((scm-eq? token '?)                        
	 (tokenizer 'next)
	 (scm-list 'scm-rvar))
        ((scm-eq? token '*semicolon*)
         (parser-error tokenizer "unexpected semicolon"))
	(else (let ((var (special-var-access (tokenizer 'next) tokenizer)))
                (if (slgn-is_special_token var)
                    (parser-error tokenizer "misplaced token or operator"))
                (let ((ntok (tokenizer 'peek)))
                  (cond ((eq? ntok '*period*)
                         (tokenizer 'next)
                         (closure-member-access var tokenizer))
                        ((eq? ntok '*ns-deref*)
                         (deref-expr tokenizer token))
                        (else
                         (handle-rvar-access (slgn-repr->scm-repr var)))))))))

(define (member-access/funcall-expr expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*period*)
         (begin (tokenizer 'next)
                (closure-member-access expr tokenizer)))
        ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (func-call-expr expr tokenizer))
        (else expr)))

(define scm-long-list scm-append)

(define (mk-list-literal xs)
  (let ((len (scm-length xs)))
    (if (scm-> len *max-list-literal-length*)
        (let loop ((xs xs) (n 0) (ys '()) (result '()))
          (cond ((null? xs)
                 (let ((r (if (null? ys) result (scm-cons `(scm-list ,@ys) result))))
                   `(scm-long-list ,@r)))
                ((scm-> n *max-list-literal-length*)
                 (loop (scm-cdr xs) 0 '() (scm-cons `(scm-list ,@(scm-cons (scm-car xs) ys)) result)))
                (else
                 (loop (scm-cdr xs) (scm-+ n 1) (scm-cons (scm-car xs) ys) result))))
        `(scm-list ,@(scm-reverse xs)))))

(define (list-literal tokenizer)
  (tokenizer 'next)
  (let loop ((result '()))
    (let ((token (tokenizer 'peek)))
      (if (scm-eq? token '*close-bracket*)
          (begin (tokenizer 'next)
                 (mk-list-literal result))
          (let ((expr (scm-expression tokenizer)))
            (if (scm-eq? (tokenizer 'peek) '*pipe*)
                (begin (tokenizer 'next)
                       (list-comprehension-expr tokenizer expr))
                (begin (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'list-literal)
                       (loop (scm-cons expr result)))))))))

(define (list-comprehension-expr tokenizer result-expr)
  (let ((vars-lists-filters 
         (let loop ((vars '())
                    (lists '())
                    (filters '()))
           (if (eq? (tokenizer 'peek) '*close-bracket*)
               (scm-list (scm-reverse vars) (scm-reverse lists)
                         (scm-reverse filters))
               (let ((var (scm-expression tokenizer))
                     (extractor (tokenizer 'next)))
                 (if (scm-eq? '*extractor* extractor)
                     (let ((lists (scm-cons (scm-expression tokenizer) lists))
                           (vars (scm-cons var vars))
                           (filters (scm-cons (if (scm-eq? (tokenizer 'peek) 'where)
                                                  (begin (tokenizer 'next)
                                                         (scm-expression tokenizer))
                                                  #t)
                                              filters)))
                       (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'list-comprehension-expr)
                       (loop vars lists filters))))))))
    (let ((expr (list-comprehension (scm-cadr vars-lists-filters) 
                                    (scm-car vars-lists-filters) 
                                    (scm-caddr vars-lists-filters) 
                                    result-expr)))
      (let ((t (tokenizer 'next)))
        (if (scm-not (scm-eq? t '*close-bracket*))
            (parser-error tokenizer "expected closing bracket")))
      expr)))
                    
(define (array-prefix? prefix tokenizer) 
  (or (scm-eq? prefix 'u8)
      (scm-eq? prefix 's8)
      (scm-eq? prefix 'b)
      (scm-eq? prefix 'v)
      (scm-eq? prefix 'u16)
      (scm-eq? prefix 's16)
      (scm-eq? prefix 'u32)
      (scm-eq? prefix 's32)
      (scm-eq? prefix 'u64)
      (scm-eq? prefix 's64)
      (scm-eq? prefix 'f32)
      (scm-eq? prefix 'f64)))

(define (array-prefix->constructor prefix)
  (case prefix
    ((v) 'scm-vector)
    ((u8) 'scm-u8vector)
    ((s8) 'scm-s8vector)
    ((u16) 'scm-u16vector)
    ((s16) 'scm-s16vector)
    ((u32) 'scm-u32vector)
    ((s32) 'scm-s32vector)
    ((u64) 'scm-u64vector)
    ((s64) 'scm-s64vector)
    ((f32) 'scm-f32vector)
    ((f64) 'scm-f64vector)
    (else 'bit_array)))

(define (array-literal tokenizer)
  (let ((prefix (tokenizer 'peek)))
    (if (array-prefix? prefix tokenizer)
        (tokenizer 'next)
        (set! prefix 'v))
    (if (scm-eq? (tokenizer 'peek) '*open-bracket*)
        (begin (tokenizer 'next)
               (let loop ((expr (scm-list (array-prefix->constructor prefix)))
                          (token (tokenizer 'peek)))
                 (cond ((scm-eq? token '*close-bracket*)
                        (tokenizer 'next)
                        (scm-reverse expr))
                       (else (let ((e (scm-expression tokenizer)))
                               (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'array-literal)
                               (loop (scm-cons e expr) (tokenizer 'peek)))))))
        (parser-error tokenizer "invalid start of array literal"))))

(define (table-literal mkset? tokenizer)
  (tokenizer 'next)
  (let ((close-token (if mkset? '*close-paren* '*close-brace*)))
    (let loop ((args '()))
      (if (scm-eq? (tokenizer 'peek) close-token)
          (begin
            (tokenizer 'next)
            (if mkset?
                `(make-set ,@args)
                `(make-equal-hashtable (scm-list ,@args))))
          (let ((keyval (let ((e (scm-expression tokenizer)))
                          (if (and (tokenizer 'let-pattern-mode?)
                                   (symbol? e))
                              (scm-list 'scm-cons (scm-list 'quote e) e)
                              e))))
            (begin
              (if (and (scm-not mkset?)
                       (scm-not (and
                                 (pair? keyval)
                                 (scm-eq? (scm-car keyval) 'scm-cons))))
                  (parser-error tokenizer "expected key-value pair"))
              (assert-comma-separator tokenizer close-token *enforce-comma* 'table-literal)
              (loop (scm-cons keyval args))))))))
    
(define (array-or-table-literal tokenizer)
  (tokenizer 'next)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token '*open-brace*)
           (table-literal #f tokenizer))
          ((scm-eq? token '*open-paren*)
           (table-literal #t tokenizer))
          (else
           (array-literal tokenizer)))))

(define (for-bindings tokenizer)
  (let loop ((token (tokenizer 'peek)) (bindings '()))
    (cond ((or (scm-eq? token '*close-paren*)
               (scm-eq? token '*semicolon*)
               (scm-eq? token 'to)
               (scm-eq? token 'downto))
	   bindings)
	  ((symbol? token)
           (check-if-reserved-name token tokenizer)
           (tokenizer 'next)
           (if (scm-not (scm-eq? (tokenizer 'next) '*assignment*))
               (parser-error tokenizer "expected assignment"))
           (let ((expr (scm-expression tokenizer)))
             (let ((next (tokenizer 'peek)))
               (if (scm-eq? next '*comma*) 
                   (tokenizer 'next)))
             (loop (tokenizer 'peek) (scm-cons (scm-list token expr) bindings))))
          (else (parser-error tokenizer "expected variable declaration")))))

(define *no-nxt-expr* '*no-nxt-expr*)

(define (for-expr tokenizer)
  (cond ((eq? (tokenizer 'peek) 'for)
         (tokenizer 'next)
         (if (scm-not (eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "expected opening parenthesis"))
         (let ((bindings (for-bindings tokenizer))
               (tok (tokenizer 'next))
               (counter #f) (limit-expr #f) (range-kw #f))
           (if (or (eq? tok 'to) (eq? tok 'downto))
               (begin (set! range-kw tok)
                      (set! counter (scm-caar bindings))
                      (set! limit-expr (scm-expression tokenizer)))
               (if (scm-not (eq? '*semicolon* tok))
                   (parser-error tokenizer "expected semicolon")))
           (let ((cond-expr (if counter
                                (if (eq? range-kw 'to)
                                    `(lteq-compare ,counter ,limit-expr)
                                    `(gteq-compare ,counter ,limit-expr))
                                (if (eq? '*semicolon* (tokenizer 'peek)) #t (scm-expression tokenizer)))))
             (if (and (scm-not counter)
                      (scm-not (eq? '*semicolon* (tokenizer 'next))))
                 (parser-error tokenizer "expected semicolon"))
             (let ((nxt-expr (if counter
                                 (if (eq? range-kw 'to)
                                     `(scm-+ ,counter 1)
                                     `(scm-- ,counter 1))
                                 (if (eq? '*close-paren* (tokenizer 'peek)) *no-nxt-expr* (scm-expression tokenizer)))))
               (if (scm-not (eq? (tokenizer 'next) '*close-paren*))
                   (parser-error tokenizer "expected closing parenthesis"))
               (let ((counter (or counter (if (scm-not (null? bindings)) (scm-caar bindings) #f))))
                 `(call/cc (lambda (break)
                             (let* ,(scm-append '((*for-value* #f)) (scm-reverse bindings))
                               (let *for-loop* ()
                                 (if ,cond-expr
                                     (begin
                                       (set! *for-value*
                                             (call/cc (lambda (continue)
                                                        ,(func-body-expr tokenizer #f #f))))
                                       ,(if counter
                                            (if (scm-not (eq? nxt-expr *no-nxt-expr*))
                                                `(set! ,counter ,nxt-expr))
                                            nxt-expr)
                                       (*for-loop*))
                                     *for-value*))))))))))
        (else  (func-call-expr (literal-expr tokenizer) tokenizer))))

(define (make-dyn-un/bind-exprs bindings)
  (scm-map (lambda (b)
             (let ((var (scm-car b)) (val (scm-cadr b)))
               (if (scm-not (dynamic-var? var))
                   (scm-error "not a valid dynamic variable name" var))
               (scm-cons
                `(task-binding-set! (current-thread) ',var ,val)
                `(task-binding-remove! (current-thread) ',var))))
           bindings))

(define (letdyn-expr tokenizer)
  (tokenizer 'next)
  (let* ((bindings (let-bindings tokenizer 'letdyn))
         (bind-unbind-exprs (make-dyn-un/bind-exprs bindings))
         (bind-exprs (scm-map scm-car bind-unbind-exprs))
         (unbind-exprs (scm-map scm-cdr bind-unbind-exprs)))
    `(let ()
       ,@bind-exprs
       (let ((**letdyn-val** ,(func-body-expr tokenizer '())))
         ,@unbind-exprs
         **letdyn-val**))))

(define (let-expr tokenizer)
  (if (eq? (tokenizer 'peek) 'letdyn)
      (letdyn-expr tokenizer)
      (let ((letkw (letkw? (tokenizer 'peek))))
        (if letkw
            (begin (tokenizer 'next)
                   (if (valid-identifier? (tokenizer 'peek))
                       (named-let-expr letkw tokenizer)
                       (normal-let-expr letkw tokenizer)))
            (for-expr tokenizer)))))

(define (extract-let-binding-names bindings)
  (let loop ((bindings bindings) (vars '()))
    (if (null? bindings)
        (scm-cons '*let* (scm-reverse vars))
        (loop (scm-cdr bindings) (scm-cons (scm-caar bindings) vars)))))

(define (normal-let-expr letkw tokenizer)
  (let ((bindings (let-bindings tokenizer letkw)))
    (scm-list letkw bindings (func-body-expr tokenizer (extract-let-binding-names bindings)))))

(define (named-let-expr letkw tokenizer)
  (if (scm-not (scm-eq? letkw 'let))
      (parser-error tokenizer (string-append "cannot define " (symbol->string letkw)
                                             " as a named let")))
  (let ((name (tokenizer 'next))
        (bindings (let-bindings tokenizer letkw)))
    (scm-list letkw name
              bindings (func-body-expr tokenizer (extract-let-binding-names bindings)))))

(define (let-pattern-gensym)
  (let ((s (symbol->string (scm-gensym))))
    (string->symbol (string-append s "-letpb"))))

(define (let-ignore-var)
  (let ((s (symbol->string (scm-gensym))))
    (string->symbol (string-append s "-let-ignore"))))

(define (make-let-pattern-bindings-for-table tokenizer expr-name pexpr bindings)
  (if (null? pexpr)
      bindings
      (let* ((f (scm-car pexpr))
             (k (scm-cadr f))
             (n (scm-caddr f)))
        (cond
         ((pair? n)
          (make-let-pattern-bindings-for-table
           tokenizer expr-name (scm-cdr pexpr)
           (scm-append bindings (make-let-pattern-bindings
                                 tokenizer `(scm-ref ,expr-name ,k)
                                 (let-pattern-gensym) n '() 0))))
         (else
          (check-if-reserved-name n tokenizer)
          (if (scm-not (scm-eq? '_ n))
              (make-let-pattern-bindings-for-table
               tokenizer expr-name (scm-cdr pexpr)
               (scm-cons (scm-cons n `((scm-ref ,expr-name ,k))) bindings))
              (make-let-pattern-bindings-for-table
               tokenizer expr-name (scm-cdr pexpr) bindings)))))))

(define (let-pair-part-bindings part expr-name first? tokenizer)
  (let ((extractor (if first? 'scm-car 'scm-cdr)))
    (cond
     ((pair? part)
      (make-let-pattern-bindings
       tokenizer `(,extractor ,expr-name) (let-pattern-gensym)
       part '() 0))
     ((scm-not (valid-identifier? part))
      (parser-error tokenizer "invalid indentifier in pair binding pattern"))
     ((scm-not (scm-eq? '_ part))
      (scm-cons (scm-cons part `((,extractor ,expr-name))) '()))
     (else '()))))

(define (make-let-pattern-bindings tokenizer expr expr-name pexpr bindings i)
  (if (null? pexpr)
      (scm-cons (scm-cons expr-name (scm-list expr)) bindings)
      (let ((pname (scm-car pexpr)))
        (cond
         ((pair? pname)
          (let ((f (scm-car pname)))
            (case f
              ((scm-list scm-cons make-equal-hashtable)
               (let ((sub-bindings
                      (make-let-pattern-bindings
                       tokenizer `(scm-nth ,i ,expr-name)
                       (let-pattern-gensym)
                       (if (scm-eq? f 'scm-list)
                           (scm-cdr pname)
                           pname)
                       '() 0)))
                 (make-let-pattern-bindings
                  tokenizer expr expr-name (scm-cdr pexpr)
                  (scm-append bindings sub-bindings) (scm-+ i 1))))
              (else (parser-error tokenizer "invalid pattern tag")))))
         ((scm-eq? pname 'scm-list)
          (make-let-pattern-bindings
           tokenizer expr expr-name
           (scm-cdr pexpr) bindings i))
         ((scm-eq? pname 'scm-cons)
          (let ((new-bindings
                 (scm-append
                  (let-pair-part-bindings (scm-cadr pexpr) expr-name #t tokenizer)
                  (let-pair-part-bindings (scm-caddr pexpr) expr-name #f tokenizer))))
            (make-let-pattern-bindings
             tokenizer expr expr-name
             '() (scm-append bindings new-bindings) i)))
         ((scm-eq? pname 'make-equal-hashtable)
          (make-let-pattern-bindings
           tokenizer expr expr-name '()
           (scm-append bindings (make-let-pattern-bindings-for-table
                                 tokenizer expr-name (scm-cdadr pexpr) '())) i))
         ((scm-not (valid-identifier? pname))
          (parser-error tokenizer "invalid binding name in pattern"))
         (else
          (if (scm-eq? pname '_)
              (make-let-pattern-bindings
               tokenizer expr expr-name
               (scm-cdr pexpr) bindings (scm-+ i 1))
              (make-let-pattern-bindings
               tokenizer expr expr-name
               (scm-cdr pexpr)
               (scm-cons (scm-cons pname `((scm-nth ,i ,expr-name)))
                         bindings)
               (scm-+ i 1))))))))

(define (let-pattern-binding? pattern-expr)
  (and (pair? pattern-expr)
       (let ((s (scm-car pattern-expr)))
         (or (scm-eq? s 'scm-list)
             (scm-eq? s 'scm-cons)
             (scm-eq? s 'make-equal-hashtable)))))

(define (scm-let-pattern-expression tokenizer)
  (with-exception-catcher
   (lambda (e)
     (tokenizer 'let-pattern-mode-off)
     (scm-raise e))
   (lambda ()
     (tokenizer 'let-pattern-mode-on)
     (let ((expr (scm-expression tokenizer)))
       (tokenizer 'let-pattern-mode-off)
       expr))))

(define (let-pattern-bindings tokenizer)
  (let ((pattern-expr (scm-let-pattern-expression tokenizer)))
    (if (scm-not (let-pattern-binding? pattern-expr))
        (parser-error tokenizer "invalid binding name or pattern"))
    (if (scm-not (scm-eq? (tokenizer 'next) '*assignment*))
        (parser-error tokenizer "expected assignment"))
    (let ((expr (scm-expression tokenizer))
          (expr-name (let-pattern-gensym)))
      (make-let-pattern-bindings
       tokenizer expr expr-name pattern-expr '() 0))))

(define (assert-pattern-bindings-let tokenizer letkw)
  (if (scm-not (scm-eq? letkw 'let*))
      (parser-error tokenizer "pattern bindings is allowed only in let")))

(define (let-bindings tokenizer letkw)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
      (parser-error tokenizer "expected let variable bindings list"))
  (let loop ((token (tokenizer 'next))
	     (bindings '()))
    (cond ((scm-eq? token '*close-paren*)
	   bindings)
          ((or (scm-eq? token '*open-bracket*)
               (scm-eq? token '*hash*))
           (assert-pattern-bindings-let tokenizer letkw)
           (tokenizer 'put token)
           (let ((pbindings (let-pattern-bindings tokenizer)))
             (if (scm-eq? (tokenizer 'peek) '*comma*)
                 (tokenizer 'next))
             (loop (tokenizer 'next) (scm-append bindings pbindings))))
	  ((symbol? token)
           (cond
            ((scm-eq? (tokenizer 'peek) '*colon*)
             (assert-pattern-bindings-let tokenizer letkw)
             (tokenizer 'put token)
             (let ((pbindings (let-pattern-bindings tokenizer)))
               (if (scm-eq? (tokenizer 'peek) '*comma*)
                   (tokenizer 'next))
               (loop (tokenizer 'next) (scm-append bindings pbindings))))
            (else
             (check-if-reserved-name token tokenizer)
             (let ((token (if (eq? token '_) (let-ignore-var) token)))
               (if (scm-not (scm-eq? (tokenizer 'next) '*assignment*))
                   (parser-error tokenizer "expected assignment"))
               (let ((expr (scm-expression tokenizer)))
                 (let ((next (tokenizer 'peek)))
                   (if (scm-eq? next '*comma*)
                       (tokenizer 'next)))
                 (loop
                  (tokenizer 'next)
                  (scm-append bindings (scm-list (scm-list token expr)))))))))
          (else
           (parser-error tokenizer "invalid let binding name")))))

(define (letkw? sym)
  (if (and (symbol? sym)
	   (or (scm-eq? sym 'let)
	       (scm-eq? sym 'letfn)
	       (scm-eq? sym 'letrec)))
      (cond ((scm-eq? sym 'let)
             'let*)
            ((scm-eq? sym 'letfn)
             'let)
            (else sym))
      #f))

(define (list-literal? s)
  (or (eq? s 'scm-list) (eq? s 'scm-long-list)))

(define (module-export-name-expr tokenizer)
  (let ((t (tokenizer 'peek)))
    (cond ((dynamic-var? t)
           (tokenizer 'next)
           t)
          (else
           (scm-expression tokenizer)))))

(define (mod-exports-list tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-not (scm-eq? '*open-paren* token))
           (parser-error tokenizer "expected module exports list"))
          (else
           (tokenizer 'next)
           (let loop ((exports '()))
             (let ((token (tokenizer 'peek)))
               (if (scm-not (scm-eq? token '*close-paren*))
                   (let ((expr (module-export-name-expr tokenizer)))
                     (cond ((symbol? expr)
                            (check-if-reserved-name expr tokenizer)
                            (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'mod-exports-list)
                            (loop (scm-cons expr exports)))
                           ((pair? expr)
                            (cond ((scm-eq? (scm-car expr) 'scm-cons)
                                   (let ((expr (scm-cons (scm-cadr expr) (scm-caddr expr))))
                                     (check-if-reserved-name (scm-car expr) tokenizer)
                                     (check-if-reserved-name (scm-cdr expr) tokenizer)
                                     (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'mod-exports-list-2)
                                     (loop (scm-cons expr exports))))
                                  ((list-literal? (scm-car expr))
                                   (loop (scm-cons (scm-cdr expr) exports)))
                                  (else
                                   (parser-error tokenizer "invalid export description"))))
                           (else
                            (parser-error tokenizer "invalid name in exports"))))
                   (begin
                     (tokenizer 'next)
                     (if (null? exports)
                         (parser-error tokenizer "empty exports list"))
                     (scm-reverse exports)))))))))

(define (diff-exports defs-in-body exclude)
  (if (null? exclude)
      defs-in-body
      (let loop ((e defs-in-body) (exports '()))
        (cond ((null? e)
               (scm-reverse exports))
              ((scm-memq (scm-car e) exclude)
               (loop (scm-cdr e) exports))
              (else
               (loop (scm-cdr e) (scm-cons (scm-car e) exports)))))))

(define (extract-module-defs body defs)
  (if (null? body)
      defs
      (let ((e (scm-car body)))
        (cond ((pair? e)
               (extract-module-defs
                (scm-cdr body)
                (cond ((or (scm-eq? 'define (scm-car e))
                           (scm-eq? 'set! (scm-car e))) ; redefine and export a global.
                       (scm-cons (scm-cadr e) defs))
                      ((scm-eq? 'begin (scm-car e))
                       (extract-module-defs (scm-cdr e) defs))
                      (else defs))))
              ((symbol? e)
               (extract-module-defs (scm-cdr body)
                                    (if (or (scm-eq? 'define e) (scm-eq? 'set! e))
                                        (scm-cons (scm-cadr body) defs)
                                        defs)))
              (else (extract-module-defs (scm-cdr body) defs))))))

(define (check-if-body-has-exported-names body exports)
  (let ((defs-in-body (extract-module-defs body '())))
    (if (eq? (scm-car exports) '_)
        (diff-exports defs-in-body (if (scm-not (null? (scm-cdr exports)))
                                       (scm-cadr exports)
                                       '()))
        (let loop ((exps exports))
          (if (null? exps)
              exports
              (let ((e (scm-car exps)))
                (if (scm-memq (if (symbol? e) e (scm-cdr e)) defs-in-body)
                    (loop (scm-cdr exps))
                    (scm-error "exported name not found in definitions" e))))))))

(define (merge-module name exports body)
  (let ((exports (check-if-body-has-exported-names body exports)))
    (let ((dispatch-expr
           (let loop ((es exports)
                      (dispatcher `(case *name*)))
             (if (null? es)
                 `(if *name*
                      ,(scm-append dispatcher '((else (scm-error (quote name_not_found) *name*))))
                      ',exports)
                 (let ((n (scm-car es)))
                   (if (symbol? n)
                       (loop (scm-cdr es) (scm-append dispatcher `(((,n) ,n))))
                       (loop (scm-cdr es) (scm-append dispatcher `(((,(scm-car n)) ,(scm-cdr n)))))))))))
      (let ((body-expr (scm-list 'let '() body `(lambda (#!optional *name*) ,dispatch-expr))))
        (if name `(define ,name ,body-expr) body-expr)))))
                       
(define (module-def-expr tokenizer)
  (cond ((scm-eq? 'module (tokenizer 'peek))
         (tokenizer 'next)
         (let ((mod-name (tokenizer 'peek)))
           (if (scm-not (symbol? mod-name))
               (parser-error tokenizer "expected module name")
               (if (eq? mod-name '*open-paren*)
                   (set! mod-name #f)
                   (begin (tokenizer 'next)
                          (check-if-reserved-name mod-name tokenizer))))
           (let ((mod-exports (mod-exports-list tokenizer))
                 (mod-body (func-body-expr tokenizer '())))
             (merge-module mod-name mod-exports mod-body))))
        (else (namespace-def-expr tokenizer))))

(define (namespace-def-expr tokenizer)
  (cond ((scm-eq? 'namespace (tokenizer 'peek))
         (tokenizer 'next)
         (let ((ns-name (tokenizer 'next)))
           (if (scm-not (valid-identifier? ns-name))
               (parser-error tokenizer "invalid namespace identifier"))
           (let ((ns-body (func-body-expr tokenizer '())))
             (make-namespace-expr ns-name ns-body))))
        (else #f)))

(define (func-def-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? '*fn* token) (scm-eq? 'function token))
        (begin (tokenizer 'next)
               (let* ((params (scm-car (func-params-expr tokenizer #f)))
                      (body-expr (func-body-expr tokenizer params)))
                 (merge-lambda tokenizer params body-expr)))
        (module-def-expr tokenizer))))

(define (merge-lambda tokenizer params lambda-body)
  (let ((expr (let ((lambda-expr (scm-list 'lambda params)))
                (if (scm-not (list? lambda-body))
                    (set! lambda-body (scm-list 'begin lambda-body)))
                (if (scm-<= 1 (scm-length lambda-body))
                    (scm-append lambda-expr (scm-list lambda-body))
                    (let loop ((lambda-expr lambda-expr)
                               (lambda-body (if (scm-eq? (scm-car lambda-body) 'begin)
                                                (scm-cdr lambda-body)
                                                lambda-body)))
                      (if (null? lambda-body)
                          lambda-expr
                          (loop (scm-append lambda-expr (scm-list (scm-car lambda-body)))
                                (scm-cdr lambda-body))))))))
    (if (scm-> (tokenizer 'yield-count) 0)
        (tokenizer 'reset-yield-count))
    expr))

(define (wrap-in-return-cont expr)
  `(call/cc (lambda (*return*)
              (let ((*yield-obj* (make-s-yield #f *return*)))
                (begin ,expr
                       (let ((*r* (s-yield-k *yield-obj*)))
                         (s-yield-fn-set! *yield-obj* #f)
                         (*r* *yield-obj*)))))))

(define (stmt-or-expr tokenizer)
  (let ((expr (scm-statement tokenizer)))
    (if (scm-not expr)
        (scm-expression tokenizer)
        expr)))

(define (extract-param-names params)
  (let loop ((params params) (res '()))
    (if (null? params)
      (scm-reverse res)
      (let ((p (scm-car params)))
        (cond
         ((or (eq? #!optional p) (eq? #!key p) (eq? #!rest p))
          (loop (scm-cdr params) res))
         ((symbol? p) (loop (scm-cdr params) (scm-cons p res)))
         ((pair? p) (loop (scm-cdr params) (scm-cons (scm-car p) res)))
         (else (loop (scm-cdr params) res)))))))

(define (func-body-expr tokenizer params #!optional (use-let #f))
  (with-exception-catcher
   (lambda (e)
     (pop-syntax-context!)
     (scm-raise e))
   (lambda ()
     (push-syntax-context!)
     (let ((result-expr
            (let ((implicit-match? #f)
                  (let-expr? (and params (scm-> (scm-length params) 0) (eq? '*let* (scm-car params)))))
              (let ((params (if let-expr? (scm-cdr params) params)))
                (if (scm-eq? (tokenizer 'peek) '*pipe*)
                    (if (and params (scm-> (scm-length params) 0))
                        (begin
                          (tokenizer 'next)
                          (set! implicit-match? #t))
                        (parser-error tokenizer "implicit match cannot be specified here")))
                (let ((match-value (if implicit-match?
                                       (let ((params (extract-param-names params)))
                                         (if (scm-= (scm-length params) 1)
                                             (scm-car params)
                                             (scm-append '(scm-list) (extract-param-names params))))
                                       #f)))
                  (let ((old-yield-count (tokenizer 'yield-count)))
                    (let ((body-expr
                           (let ((token (tokenizer 'peek)))
                             (if (or (scm-eq? token '*semicolon*)
                                     (eof-object? token))
                                 '(begin (quote ()))
                                 (if implicit-match?
                                     (match-body-expr match-value tokenizer)
                                     (if (scm-eq? (tokenizer 'peek) '*open-brace*)
                                         (block-expr tokenizer use-let)
                                         (stmt-or-expr tokenizer)))))))
                      (if (and (scm-not let-expr?) params (scm-> (tokenizer 'yield-count) old-yield-count))
                          (wrap-in-return-cont body-expr)
                          body-expr))))))))
       (pop-syntax-context!)
       result-expr))))

(define (func-call-expr func-val tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token '*open-paren*)
           (if (and (symbol? func-val)
                    (check-if-reserved-name func-val tokenizer)
                    (tokenizer 'pattern-mode?))
               (let ((s (symbol->string func-val)))
                 (set! func-val (string->symbol (string-append "+" s)))))
           (tokenizer 'next)
           (invoke-access-expression
            tokenizer
            (let ((expr (mk-func-call-expr tokenizer func-val)))
              (cond ((scm-eq? (tokenizer 'peek) '*close-paren*)
                     (tokenizer 'next) 
                     (if (scm-eq? (tokenizer 'peek) '*period*)
                         (member-access/funcall-expr expr tokenizer)
                         expr))
                    (else (parser-error
                           tokenizer
                           "missing closing parenthesis after function argument list"))))))
          ((scm-eq? token '*open-bracket*)
           (array-access-expr tokenizer func-val))
          (else func-val))))

(define (mk-func-call-expr tokenizer func-val)
  (let ((expr (func-args-expr tokenizer)))
    (scm-cons func-val expr)))

(define (record-def-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'record)
      (begin (tokenizer 'next)
	     (let ((token (tokenizer 'peek)))
	       (if (scm-not (valid-identifier? token))
		   (parser-error tokenizer "missing record name"))
	       (mk-record-expr (tokenizer 'next) tokenizer)))
      (assignment-stmt tokenizer)))

(define (rec-get-precond tokenizer)
  (tokenizer 'next)
  (let ((precond (scm-expression tokenizer)))
    (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-precond)
    precond))

(define (mk-rec-type-check-expr field-name type-name)
  (let ((predic-name (string->symbol (string-append "is_" (symbol->string type-name)))))
    `(,predic-name ,field-name)))

(define (rec-get-field-def tokenizer field-name)
  (let ((token (tokenizer 'peek)))
    (cond
     ((scm-eq? token '*assignment*)
      (tokenizer 'next)
      (let ((val (scm-expression tokenizer)))
        (if (scm-eq? (tokenizer 'peek) 'where)
            (scm-cons val (rec-get-precond tokenizer))
            (begin (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def)
                   (scm-cons val #t)))))
     ((scm-eq? token '*colon*)
      (tokenizer 'next)
      (let ((type-name (tokenizer 'next)))
        (if (symbol? type-name)
            (if (eq? (tokenizer 'peek) '*assignment*)
                (begin (tokenizer 'next)
                       (let ((expr (scm-cons (scm-expression tokenizer) (mk-rec-type-check-expr field-name type-name))))
                         (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def)
                         expr))
                (let ((expr (scm-cons #f (mk-rec-type-check-expr field-name type-name))))
                  (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def)
                  expr))
            (parser-error tokenizer "expected a type name"))))
     (else
      (if (scm-eq? token 'where)
          (scm-cons #f (rec-get-precond tokenizer))
          (begin (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def-3)
                 (scm-cons #f #t)))))))

(define (mk-record-expr name tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((token (tokenizer 'peek))
                    (members '()) (default-values '())
                    (preconds '()))
           (cond ((valid-identifier? token)
                  (let ((token (tokenizer 'next))
                        (fdef (rec-get-field-def tokenizer token)))
                    (loop (tokenizer 'peek) (scm-cons token members)
                          (scm-cons (scm-car fdef) default-values) 
                          (scm-cons (scm-cdr fdef) preconds))))
                 ((scm-eq? token '*close-paren*)
                  (tokenizer 'next)
                  (def-struct-expr name (scm-reverse members) (scm-reverse default-values) (scm-reverse preconds)))
                 (else (parser-error tokenizer "invalid record specification")))))
        (else (parser-error tokenizer "expected record member specification"))))

(define (assert-rec-member-name s)
  (if (symbol? s)
      (let ((str (symbol->string s)))
        (if (char=? (string-ref str 0) #\@)
            (scm-error "record member's name cannot start with the @ character" s)
            s))
      (scm-error "record member must be a valid identifier" s)))

(define (def-struct-expr name members default-values preconds)
  (let ((members (scm-map assert-rec-member-name members)))
    (scm-append (scm-list 'begin (scm-append (scm-list 'define-structure name) members))
                (mk-struct-accessors/modifiers name members default-values preconds))))

(define (mk-record-precond-expr precond mem)
  (if (scm-eq? precond #t)
      precond
      `(if (scm-not ,precond)
           (scm-error 'precondition_failed ,mem)
           ,mem)))

(define (mk-record-precond-exprs preconds mems)
  (let loop ((preconds preconds) (mems mems) (result '()))
    (if (null? preconds) (scm-append (scm-list 'begin) (scm-reverse result))
        (loop (scm-cdr preconds) (scm-cdr mems)
              (if (scm-eq? #t (scm-car preconds))
                  result
                  (scm-cons (mk-record-precond-expr (scm-car preconds) (scm-car mems)) result))))))
        
(define (mk-record-constructor recname members default-values preconds)
  (scm-append (scm-list 'lambda (scm-append (scm-list '#!key) (mk-record-constructor-params members default-values)))
          (scm-list (mk-record-precond-exprs preconds members) 
                (scm-cons (string->symbol (string-append "make-" recname)) members))))

(define (mk-record-constructor-params members default-values)
  (let loop ((members members) (default-values default-values) 
             (params '()))
    (cond ((null? members) (scm-reverse params))
          (else (loop (scm-cdr members) (scm-cdr default-values)
                      (scm-cons (scm-list (scm-car members) 
                                  (scm-car default-values)) params))))))

(define (mk-struct-accessors/modifiers name members default-values preconds)
  (let ((sname (symbol->string name)))
    (let loop ((members members)
               (preconds preconds)
               (i 0)
               (expr (scm-list
                      `(define ,(string->symbol (string-append "members@" sname)) ',members)
                      (scm-list 'define (string->symbol sname) 
                            (mk-record-constructor sname members default-values preconds))
                      (scm-list 'define (string->symbol (string-append "make_" sname))
                            (string->symbol (string-append "make-" sname)))
                      (scm-list 'define 
                            (string->symbol (string-append "is_" sname))
                            (string->symbol (string-append sname "?"))))))
      (if (null? members) (scm-reverse expr)
          (begin (loop (scm-cdr members) (scm-cdr preconds) (scm-+ i 1)
                       (scm-append expr (member-accessor/modifier name (scm-car members) (scm-car preconds) i))))))))

(define (member-accessor/modifier name mem precond index)
  (let ((sname (symbol->string name))
	(smem (symbol->string mem)))
    (let ((scm-accessor (string->symbol (string-append sname "-" smem)))
	  (scm-modifier (string->symbol (string-append sname "-" smem "-set!")))
	  (slgn-accessor (string->symbol (string-append sname "_" smem)))
          (idx-accessor (string->symbol (string-append sname "-" (number->string index))))
	  (slgn-modifier (string->symbol (string-append sname "_set_" smem))))
      (scm-list (scm-list 'define slgn-accessor scm-accessor)
            (scm-list 'define idx-accessor scm-accessor)
	    (scm-list 'define slgn-modifier (scm-append (scm-list 'lambda (scm-list '*s* mem)) 
                                                (scm-append (if (scm-eq? #t precond) '() (scm-list (mk-record-precond-expr precond mem)))
                                                        (scm-list (scm-list scm-modifier '*s* mem)))))))))

(define (assert-comma-separator tokenizer end-seq-char comma-required caller)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*comma*)
            (if (list? end-seq-char) 
                (scm-memq token end-seq-char) 
                (scm-eq? token end-seq-char)))
        (if (scm-eq? token '*comma*) (tokenizer 'next))
        (if comma-required
            (parser-error tokenizer (with-output-to-string
                                      '()
                                      (lambda ()
                                        (scm-display "missing comma or ")
                                        (scm-display end-seq-char) 
                                        (scm-display ".")
                                        (scm-display "(")
                                        (scm-display caller)
                                        (scm-display ")"))))))))

(define (func-args-expr tokenizer)
  (let loop ((args '()))
    (let ((token (tokenizer 'peek)))
      (if (scm-not (scm-eq? token '*close-paren*))
          (cond ((valid-identifier? token)
                 (let ((sym (tokenizer 'next)))
                   (if (scm-eq? (tokenizer 'peek) '*assignment*)
                       (begin (tokenizer 'next)
                              (let ((expr (scm-expression tokenizer)))
                                (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-args-expr)
                                (loop (scm-append args (scm-list (slgn-variable->scm-keyword sym) expr)))))
                       (begin (tokenizer 'put sym)
                              (let ((expr (scm-expression tokenizer)))
                                (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-args-expr-2)
                                (loop (scm-append args (scm-list expr))))))))
                (else
                 (let ((expr (scm-expression tokenizer)))
                   (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-args-expr-3)
                   (loop (scm-append args (scm-list expr))))))
          args))))

(define (check-if-reserved-name sym tokenizer)
  (if (scm-not (valid-identifier? sym))
      (parser-error tokenizer (string-append "invalid use of keyword or operator: "
                                             (symbol->string sym) ". ") sym)
      sym))

(define (valid-identifier? sym)
  (and (symbol? sym)
       (scm-not (or (reserved-name? sym)
                    (slgn-is_special_token sym)
                    (fetch-syntax sym)
                    (fetch-macro sym)))))

(define *local-sym-count* 0)
(define (local-gensym)
  (let ((s (string-append
            "**--g" (number->string *local-sym-count*)
            "--**")))
    (set! *local-sym-count* (scm-+ 1 *local-sym-count*))
    (string->symbol s)))

(define (check-func-param tokenizer) 
  (check-if-reserved-name (tokenizer 'peek) tokenizer)
  (let ((sym (tokenizer 'next)))
    (if (scm-eq? sym '_) (local-gensym) sym)))

(define (func-param-type tokenizer)
  (let ((type (cond ((scm-eq? (tokenizer 'peek) '*colon*)
                     (tokenizer 'next)
                     (let ((s (tokenizer 'next)))
                       (if (symbol? s) s (parser-error tokenizer "expected type name"))))
                    (else '_))))
    (if (scm-not (scm-eq? (tokenizer 'peek) '*assignment*))
        (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-param-type))
    type))

(define (func-params-expr tokenizer params-required?)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((params '()) (types '())
                    (directives-found #f))
           (let ((token (tokenizer 'peek)))
             (cond
              ((valid-identifier? token)
               (let ((sym (check-func-param tokenizer)))
                 (cond
                  ((param-directive? sym)
                   (loop (scm-cons (slgn-directive->scm-directive sym) params)
                         (if (scm-eq? sym '@rest) (scm-cons sym types) types)
                         #t))
                  ((scm-eq? (tokenizer 'peek) '*assignment*)
                   (tokenizer 'next)
                   (let ((expr (scm-expression tokenizer)))
                     (if directives-found
                         (loop (scm-cons (scm-list sym expr) params)
                               (scm-cons (func-param-type tokenizer) types)
                               directives-found)
                         (loop (scm-cons
                                (scm-list sym expr)
                                (scm-cons
                                 (slgn-directive->scm-directive '@optional) params))
                               (scm-cons (func-param-type tokenizer) types)
                               #t))))
                  (else
                   (let ((type (func-param-type tokenizer)))
                     (cond
                      ((scm-eq? (tokenizer 'peek) '*assignment*)
                       (tokenizer 'next)
                       (let ((expr (scm-expression tokenizer)))
                         (if (scm-eq? (tokenizer 'peek) '*comma*)
                             (tokenizer 'next))
                         (if directives-found
                             (loop (scm-cons (scm-list sym expr) params)
                                   (scm-cons type types)
                                   directives-found)
                             (loop (scm-cons
                                    (scm-list sym expr)
                                    (scm-cons
                                     (slgn-directive->scm-directive '@optional) params))
                                   (scm-cons type types)
                                   #t))))
                      (else
                       (loop (scm-cons sym params)
                             (scm-cons type types)
                             directives-found))))))))
              (else
               (if (scm-eq? token '*close-paren*)
                   (begin (tokenizer 'next)
                          (scm-cons (scm-reverse params) (scm-reverse types)))
                   (parser-error tokenizer "missing closing parenthesis after parameter list")))))))
        (else
	 (if params-required?
	     (parser-error tokenizer "missing parameter list")
	     (scm-cons '() '())))))

(define (param-directive? sym)
  (scm-memq sym '(@optional @key @rest)))

(define (closure-member-access var tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (let loop ((expr `(,var ',(tokenizer 'next))))
	(if (scm-eq? (tokenizer 'peek) '*period*)
	    (begin (tokenizer 'next)
		   (if (valid-identifier? (tokenizer 'peek))
		       (loop (scm-cons expr `(',(tokenizer 'next))))
		       (parser-error tokenizer "expected identifier")))
	    expr))
      (parser-error tokenizer "expected identifier")))

(define (add-expr tokenizer)
  (swap-operands (scm-cons '+ (scm-list (term-expr tokenizer)))))

(define (sub-expr tokenizer)
  (swap-operands (scm-cons '- (scm-list (term-expr tokenizer)))))

(define (mult-expr tokenizer)
  (swap-operands (scm-cons '* (scm-list (factor-expr tokenizer)))))

(define (div-expr tokenizer)
  (swap-operands (scm-cons '/ (scm-list (factor-expr tokenizer)))))

(define (eq-expr tokenizer)
  (swap-operands (scm-cons '== (scm-list (addsub-expr tokenizer)))))

(define (not-eq-expr tokenizer)
  (swap-operands (scm-cons '<> (scm-list (addsub-expr tokenizer)))))

(define (lt-expr tokenizer)
  (swap-operands (scm-cons 'lt-compare (scm-list (addsub-expr tokenizer)))))

(define (lteq-expr tokenizer)
  (swap-operands (scm-cons 'lteq-compare (scm-list (addsub-expr tokenizer)))))

(define (gt-expr tokenizer)
  (swap-operands (scm-cons 'gt-compare (scm-list (addsub-expr tokenizer)))))

(define (gteq-expr tokenizer)
  (swap-operands (scm-cons 'gteq-compare (scm-list (addsub-expr tokenizer)))))

(define (or-expr tokenizer)
  (swap-operands (scm-cons 'or (scm-list (logical-and-expr tokenizer)))))

(define (and-expr tokenizer)
  (swap-operands (scm-cons 'and (scm-list (cmpr-expr tokenizer)))))

(define (term-expr tokenizer)
  (let loop ((expr (factor-expr tokenizer)))
    (if (mult-div-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*asterisk*) (loop (swap-operands (scm-append (mult-expr tokenizer) (scm-list expr)))))
          ((*backslash*) (loop (swap-operands (scm-append (div-expr tokenizer) (scm-list expr))))))
        expr)))

(define (swap-operands expr)
  (if (scm-= 3 (scm-length expr))
      (scm-list (scm-car expr) (scm-caddr expr) (scm-cadr expr))
      expr))

(define *reserved-names* '(^ function module record true false
			     if else when let letfn letrec letdyn yield
			     case match where try trycc catch finally
			     namespace declare assert for break continue))

(define (reserved-name? sym)
  (and (symbol? sym)
       (scm-memq sym *reserved-names*)))

(define (parened-names->list tokenizer)
  (if (scm-eq? (tokenizer 'next) '*open-paren*)
      (let loop ((token (tokenizer 'next))
                 (result '()))
        (cond ((scm-eq? token '*close-paren*)
               (scm-reverse result))
              ((valid-identifier? token)
               (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'parened-names->list)
               (loop (tokenizer 'next) (scm-cons token result)))
              (else #f)))
      #f))

(define expression scm-expression)
(define slogan scm-slogan)
