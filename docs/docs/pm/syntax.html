<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>The Slogan Programming Language</title>
    <meta name="author" content="Vijay Mathew (Based on the design of Julia Language website)." />
    <link rel="stylesheet" href="../../css/julia.css" type="text/css" media="screen, projection" />
    <link rel="stylesheet" href="../../css/screen.css" type="text/css" media="screen, projection" />
    <link rel="stylesheet" href="../../css/syntax.css" type="text/css" />
  </head>
  <body>
    
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" >
          <a href="./pack.html" title="Packages"
             accesskey="P">previous</a></li>
        <li><a href="../../index.html">Slogan</a>&nbsp;/&nbsp;</li>
        <li><a href="../index.html">Documentation</a>&nbsp;/&nbsp;</li>
      </ul>
    </div>
    
    <div id="site" class="site">
      <div class="title"><h3>Building new syntax</h3></div>

      <p>New syntactic constructs can be added to Slogan. This makes it easy to implement <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSLs</a> or to experiment with language design ideas. Slogan offer two methods to add new syntax to the language. Both are discussed in this chapter.</p>

      <h3>Syntax</h3>
      <p>The simplest way to add new syntax is by using the <code>declare syntax</code> statement. It has the general form shown below:</p>
      <div class="highlight">
        <pre><code>declare syntax &lt;keyword&gt; &lt;layout&gt; =&gt; &lt;expansion&gt;</code></pre>
      </div>

      <p><code>Keyword</code> is a name that uniquely identifies the new syntactic form. <code>Layout</code> defines the structure of the extension as it will appear in code. This can contain operators, identifiers and literals. All identifiers starting with the dollar sign ($) is treated specially by the compiler. It will be replaced by a valid Slogan expression. The <code>expansion</code> part will contain Slogan code that should be generated by the compiler upon successfully parsing the new syntax.</p>

      <p>To better understand <code>declare syntax</code>, let us implement a new syntactic extension. We will add the <code>do-while</code> construct from the C programming language to Slogan. <code>Do-while</code> is an imperative loop which executes its body at-least once, even if the condition in <code>while</code> is <code>false</code>. We will define the syntax of the <code>do-while</code> loop as <code>do &lt;expression_to_execute&gt; while(&lt;condition_to_check&gt;)</code>. This syntax will expand to produce a code block that will execute <code>expression_to_execute</code> once and then go into a named <code>let</code> to conditionally execute it in a loop. The implementation of this construct follows:</p>

      <div class="highlight">
        <pre><code>declare syntax
  do $body while($condition)
  => { $body
       let loop ()
         when ($condition)
         { $body
           loop() }}

<span class="c">// Usage:</span>            
let i = 0
do { showln(i); i = i + 1 } while (i < 5)
<span class="c">//-> 0
  1
  2
  3
  4</span>
do { showln(i); i = i + 1 } while (i < 5)
<span class="c">//-> 5</span>

i = 0;
do { showln(i); i = i + 1 } while (i < 5)
<span class="c">//-> 0
1
2
3
4</span></code></pre>
</div>

<p>The code generated by <code>declare syntax</code> is <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic</a>. Free variables in the expansion code will refer to bindings visible when the syntax was specified. This is demonstrated in the following program:</p>

<div class="highlight">
  <pre><code>let x = 100

declare syntax
  prnx => showln(x)

<span class="c">// Usage:</span>      
prnx
<span class="c">//-> 100</span>
let (x = 200) prnx
<span class="c">//-> 100</span></code></pre></div>

<h3>Macros</h3>
<p>Another facility for extending the compiler is the macro system. It gives full access to the lower-level compiler APIs for generating code. These extensions are created using the <code>declare macro</code> statement which has the general form:</p>

<div class="highlight">
  <pre><code>declare macro &lt;keyword&gt; &lt;layout&gt; => &lt;expander&gt;</code></pre>
</div>

<p>The <code>keyword</code> and <code>layout</code> parts are similar to that of <code>declare syntax</code>. <code>Expander</code> is Slogan code that will be executed by the compiler to generate the actual expansion of the macro. The module <code>core.compiler</code> define functions that can generate low-level Slogan code. The <code>expander</code> will consist mostly of calls to these functions.</p>

<p>The following example shows one kind of extension that can be defined only using macros - one that introduces new variable bindings.</p>

<div class="highlight">
  <pre><code>declare macro
  bind_names ($names, $values) $body
  => let (bindings = core.map(^(n, v) [n, v], $names, $values))
       core.compiler.let_(bindings, $body)

<span class="c">// Usage:</span>
bind_names([a, b, c], [1, 2, 3]) a + b + c
<span class="c">//=> 6</span></code></pre></div>

<p>It is possible to add custom code parsers and invoke them from macros. The parsers are functions called by the compiler. So they must be defined using a <code>declare function</code> statement. Let us look at an example of this. The macro we are going to define is called <code>str</code>. It expects an asterisk symbol followed by an identifier. The macro converts the identifier to a string. In short, the <code>str</code> macro defines a DSL for converting symbols to strings. Not very useful, but enough to illustrate compile-time functions!</p>

<div class="highlight">
  <pre><code>declare function compile_ident(tokenizer)
  let (token = tokenizer.next)
  { when (core.special_token_to_string(token) <> "*")
      core.error("expected asterisk")
    let (sym = tokenizer.next)
    { when (core.not(core.is_valid_identifier(sym)))
        core.error("invalid identifier")
      sym }}

declare macro
  str $name
  => core.symbol_to_string($name),
     [$name:compile_ident]

<span class="c">// Usage:</span>        
(str * hello) == "hello"
<span class="c">//=> true</span></code></pre></div>

<p>Macros are un-hygienic in that free variables in the expander takes their definition from the context of macro expansion, not from where the macro was defined.</p>

<div class="highlight">
  <pre><code>let x = 100

declare macro
  prnx_impure => core.compiler.call('showln, ['x])

<span class="c">// Usage:</span>
prnx_impure
<span class="c">//=> 100</span>
let (x = 200) prnx_impure
<span class="c">//=> 200</span></code></pre></div>

<p>The following section documents all functions in the <code>core.compiler</code> module.</p>

<div class="highlight">
<pre><code><b>function: </b>function_(params, body)
<b>returns: </b>code to create a function object.

args - a list of identifiers that become the parameters to the function.
body - an expression that become the body of the function.

<span class="c">// Example:</span>
let f = eval(core.compiler.function_(['a, 'b], core.compiler.call('`+`, ['a, 'b])))
f(10, 20)
<span class="c">//=> 30</span></code></pre></div>

<div class="highlight">
<pre><code><b>function: </b>call(fn_name, args)
<b>returns: </b>code to call the function named fn_name with the argument list args.</code></pre></div>

<div class="highlight">
  <pre><code><b>function: </b>let_(bindings, body)
<b>function: </b>letseq_(bindings, body)
<b>function: </b>letrec_(bindings, body)
<b>function: </b>named_let(name, bindings, body)
<b>returns: </b>code to evaluate `body` in the context established by `bindings`.

<span class="c">// Examples:</span>
eval(core.compiler.let_([['a, 1], ['b, 2]], core.compiler.call('list, ['a, 'b])))
<span class="c">//=> [1, 2]</span>
eval(core.compiler.letseq_([['a, 1], ['b, 'a]], core.compiler.call('list, ['a, 'b])))
<span class="c">//=> [1, 1]</span>

<span class="c">// generate the following code:
// let iter (i = 0)
//   when (i < 5)
//   { showln(i)
//     iter(inc(i)) }</span>
eval(core.compiler.named_let('iter, [['i, 0]],
      core.compiler.when_(core.compiler.call('`<`, ['i, 5]),
        core.compiler.block([core.compiler.call('showln, ['i]),
                             core.compiler.call('iter, [core.compiler.call('inc, ['i])])]))))

<span class="c">//-> 0
1
2               
3
4</span></code></pre></div>

<div class="highlight">
  <pre><code><b>function: </b>if_(condition, consequent, alternative)
<b>function: </b>if_multi(conditions_consequences)
<b>function: </b>when_(condition, consequent)
<b>function: </b>case_(conditions_consequences)               
<b>returns: </b>code for conditional execution.

<span class="c">// Examples:</span>
eval(core.compiler.if_(core.compiler.call('`<`, [1, 2]), 100, 200))
<span class="c">//=> 100</span>
eval(core.compiler.if_multi([[core.compiler.call('`>`, [1, 2]), 100], [core.compiler.call('`>`, [2, 1]), 200], ['else, 300]]))
<span class="c">//=> 200</span>
eval(core.compiler.case_(200, [[[100], "a"], [[200], "b"], ['else, "c"]]));
<span class="c">//=> b</span></code></pre></div>

<div class="highlight">
  <pre><code><b>function: </b>let_statement(name, value)
<b>returns: </b>code to introduce a new global binding.

<span class="c">// Example:</span>
eval(core.compiler.let_statement('xyz, 123))
xyz
<span class="c">//=> 123</span></code></pre></div>

<div class="highlight">
  <pre><code><b>function: </b>assignment(name, value)
<b>returns: </b>code to assign a new value to a global binding.

<span class="c">// Example:</span>
eval(core.compiler.assignment('xyz, core.compiler.call('inc, ['xyz])))
xyz
<span class="c">//=> 124</span></code></pre></div>

<div class="highlight">
  <pre><code><b>function: </b>let_bindings_parser()
<b>returns: </b>a parser for let bindings.

<span class="c">// Example:</span>
declare macro
 doit $body where $bindings
 => core.compiler.let_($bindings, $body),
 [$bindings:core.compiler.let_bindings_parser]

doit a + b where (a = 100, b = 200)
<span class="c">//=> 300</span></code></pre></div>

<div class="highlight">
  <pre><code><b>function: </b>make_bindings_parser(letkw)
<b>returns: </b>a parser for bindings, for the given let keyword.</code></pre></div>

<h4>Limitations</h4>
<p>In the current implementation, macros and syntax cannot be exported from closures, modules and namespaces.</p>

</div>
  </body>
</html>
