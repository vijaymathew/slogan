<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="./style.css" type="text/css" />
    <title>The Slogan Handbook - Become a Language Designer!</title>
  </head>

  <body>
    <h1 class="chapter">13</h1>
    <h1 class="title">Become a Language Designer!</h1>

    <p>The chapter <a href="flow.html">Advanced Flow Control</a> ended with the promise of building control abstractions that have the same
      status as built-in ones like <code><span class="kw">try</span> and <span class="kw">yield</span></code>. We specifically mentioned
      about a control structure that will enable us to do <em>nondeterministic computing</em> in Slogan.</p>

    <p>The key idea here is that expressions in a nondeterministic language can have more than one possible value. Our nondeterministic program
      evaluator will work by automatically choosing a possible value
      and keeping track of the choice. If a subsequent requirement is not met, the evaluator will try a different choice, and it will keep
      trying new choices until the evaluation succeeds, or until we run out of choices. Nondeterministic computing has important applications
      in fields like <a href="https://en.wikipedia.org/wiki/Artificial_intelligence" target="_blank">artificial intelligence</a> and
      <a href="http://wiki.c2.com/?RelationalProgrammingLanguage" target="_blank">relational programming</a>.</p>

    <p>But before undertaking the grand job of adding nondeterminism to the language, we must become familiar with the facilities that allow us to
      build new syntactic abstractions in Slogan. Two complementary methods are available for adding new syntax to Slogan.
      The first two sections of this chapter will discuss these in some depth and show some practical examples. Then we will add
      nondeterministic operators to Slogan by taking advantage of the knowledge we gained in this chapter and the chapter on
      <a href="flow.html">flow control</a>.<a name="01-back"></a><sup><a href="#01">1</a></sup></p>

    <h2>13.1 Declaring New Syntax</h2>

    <p>The simplest way to add new syntax is by using the <code><span class="kw">declare</span> <span class="pw">syntax</span></code>
      statement. It has the general form shown below:</p>

    <div class="prog">
      <pre><code>
<span class="kw">declare</span> <span class="pw">syntax</span> &lt;keyword&gt; &lt;layout&gt; =&gt; &lt;expansion&gt;
      </code></pre>
    </div>

    <p><code>Keyword</code> is a name that uniquely identifies the new syntactic form. <code>Layout</code> defines the structure of
      the extension as it will appear in code. This can contain operators, identifiers and literals. All identifiers starting with
      the dollar sign (<code>$</code>) are treated specially by the compiler. They will be replaced by valid Slogan expressions.
      The <code>expansion</code> part will contain Slogan code that should be generated by the compiler upon successfully parsing the new syntax.</p>

    <p>The best way to understand the <code><span class="kw">declare</span> <span class="pw">syntax</span></code> statement, is to use it to implement
      a new syntactic extension. We will add the <code>do-while</code> construct from the C programming language to Slogan. <code>Do-while</code> is
      an imperative loop which executes its body at-least once, even if the condition in the <code>while</code> clause is
      <code><span class="pw">false</span></code>. We will define the syntax of the <code>do-while</code> loop as </p>

    <div class="prog">
      <pre><code>
<span class="pw">do</span> &lt;expression_to_execute&gt;
<span class="pw">while</span> (&lt;condition_to_check&gt;)
      </code></pre>
    </div>

    <p>This syntax will expand to produce a code block that will execute <code>expression_to_execute</code> once and then go into a named
      <code><span class="kw">let</span></code> to conditionally execute it in a loop, controlled by the value of <code>condition_to_check</code>.
      The implementation of this construct follows:</p>

    <div class="prog">
      <pre><code>
<span class="kw">declare</span> <span class="pw">syntax</span>
  <span class="pw">do</span> $body <span class="pw">while</span>($condition)
  =&gt; { $body
       <span class="kw">letfn</span> loop ()
        <span class="kw">when</span> ($condition)
        { $body
          loop() }}
      </code></pre>
    </div>

    <p>Some examples of using the new <code>do-while</code> loop follows:</p>

    <div class="prog">
      <pre><code>
<span class="kw">let</span> i = 0
<span class="pw">do</span>
{ showln(i)
  i = i + 1
} <span class="pw">while</span> (i &lt; 5)
<span class="comment">//&gt; 0
    1
    2
    3
    4</span>
  
<span class="pw">do</span>
{ showln(i)
  i = i + 1
} <span class="pw">while</span> (i &lt; 5)
<span class="comment">//&gt; 5</span>
      </code></pre>
    </div>

    <p>The code generated by <code><span class="kw">declare</span> <span class="pw">syntax</span></code> is
      <a href="https://en.wikipedia.org/wiki/Hygienic_macro" target="_blank">hygienic</a>. That means,
      <a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank">free variables</a> in the expansion code
      will refer to bindings visible when the syntax was specified. This is demonstrated in the following program:</p>

    <div class="prog">
      <pre><code>
<span class="kw">let</span> x = 100

<span class="kw">declare</span> <span class="pw">syntax</span>
  <span class="pw">prnx</span> =&gt; showln(x)

prnx
<span class="comment">//&gt; 100</span>
<span class="kw">let</span> (x = 200) prnx
<span class="comment">//&gt; 100</span>
      </code></pre>
    </div>

    <h2>13.2 Un-hygienic Macros</h2>

    <p>Another facility for extending the compiler is the <em>macro</em> system. It gives full access to the lower-level compiler APIs
      for generating code. These extensions are created using the <code><span class="kw">declare</span> <span class="pw">macro</span></code>
      statement which has the general form:</p>

    <div class="prog">
      <pre><code>
<span class="kw">declare</span> <span class="pw">macro</span> &lt;keyword&gt; &lt;layout&gt; =&gt; &lt;expander&gt;
      </code></pre>
    </div>

    <p>The <code>keyword</code> and <code>layout</code> parts are similar to that of
      <code><span class="kw">declare</span> <span class="pw">syntax</span></code>. <code>Expander</code> is Slogan code that will be executed
      by the compiler to generate the actual expansion of the macro. The module <code><a href="ref/compiler.html">core.compiler</a></code> define
      functions that can generate low-level Slogan code. The expander will consist mostly of calls to these functions.</p>

    <p>The following example shows a kind of extension that can be defined only by using macros &ndash; one that introduces new variable bindings.</p>

    <div class="prog">
      <pre><code>
<span class="kw">declare</span> <span class="pw">macro</span>
  <span class="pw">bind_names</span> ($names, $values) $body
  => <span class="kw">let</span> (bindings = <a href="ref/map.html">map</a>(<span class="kw">^</span>(n, v) [n, v], $names, $values))
       compiler.let_(bindings, $body)
    
<span class="comment">// Usage:</span>
<span class="pw">bind_names</span>([a, b, c], [1, 2, 3]) a + b + c
<span class="comment">// 6</span>
      </pre></code>
    </div>
    
    <p>It is possible to add custom code parsers and invoke them from macros. The parsers are functions called by the compiler.
      So they must be defined using a <code><span class="kw">declare</span> <span class="kw">function</span></code> statement. Let us look
      at an example of this. The macro we are going to define is called <code><span class="pw">str</span></code>. It expects an asterisk (<code>*</code>)
      symbol followed by an identifier. The macro converts the identifier to a string. In short, the <code>str</code> macro defines a DSL
      for converting symbols to strings. Not very useful, but good enough to illustrate compile-time parser functions!</p>

    <div class="prog">
      <pre><code>
<span class="kw">declare function</span> compile_ident(tokenizer)
  <span class="kw">let</span> (token = tokenizer.next)
  { <span class="kw">when</span> (<a href="ref/special_token_to_string.html">special_token_to_string</a>(token) &lt;&gt; <span class="str">"*"</span>)
      <a href="ref/error.html">error</a>(<span class="str">"expected asterisk"</span>)
    <span class="kw">let</span> (sym = tokenizer.next)
    { <span class="kw">when</span> (<a href="ref/not.html">not</a>(<a href="ref/is_valid_identifier.html">is_valid_identifier</a>(sym)))
        error(<span class="str">"invalid identifier"</span>)
      sym }}

<span class="kw">declare</span> <span class="pw">macro</span>
  <span class="pw">str</span> $name
  =&gt; <a href="ref/symbol_to_string.html">symbol_to_string</a>($name),
     [$name:compile_ident]

<span class="comment">// Usage:</span>
(<span class="pw">str</span> * hello) == <span class="str">"hello"</span>
<span class="comment">// true</span>
      </pre></code>
    </div>

    <p>Macros are <em>un-hygienic</em> in that free variables in the expander takes their definition from the context of macro expansion,
      not from where the macro was defined. This is demonstrated by the program below.</p>

    <div class="prog">
      <pre><code>
<span class="kw">let</span> x = 100

<span class="kw">declare</span> <span class="pw">macro</span>
  <span class="pw">prnx_impure</span> =&gt; compiler.call(<span class="sym">'showln</span>, [<span class="sym">'x</span>])

<span class="comment">// Usage:</span>
<span class="pw">prnx_impure</span>
<span class="comment">// 100</span>
<span class="kw">let</span> (x = 200) <span class="pw">prnx_impure</span>
<span class="comment">// 200</span>
      </code></pre>
    </div>

    <p>The <code><a href="ref/gensym.html">gensym</a></code> function can be used for generating symbolic names that are guaranteed not to conflict with
      names of user-defined variables.</p>
    
    <h2>13.3 Nondeterministic Computations</h2>

    <p><a name="02-back"></a>Nondeterministic computing<sup><a href="#02">2</a></sup>, like lazy sequence processing,
      is useful for "generate and test" applications. Consider the task of
      starting with two lists of positive integers and finding a pair of integers - one from the first list and one from the second list -
      whose sum is prime. In previous chapters we saw how to handle this with finite sequence operations and with infinite sequences.
      Our approach was to generate the sequence of all possible pairs and filter these to select the pairs whose sum is prime.
      Whether we actually generate the entire sequence of pairs first, or interleave the generating and filtering is immaterial to
      the essential image of how the computation is organized.</p>

    <p>The nondeterministic approach evokes a different image. Imagine simply that we choose (in some way) a number from the
      first list and a number from the second list and require (using some mechanism) that their sum be prime.
      This is expressed by the following function:</p>

    <div class="prog">
      <pre><code>
<span class="kw">function</span> prime_sum_pair(xs, ys)
  <span class="kw">let</span> (x = <span class="pw">an_element_of</span>(xs), y = <span class="pw">an_element_of</span>(ys))
  { require(<a href="ref/is_prime.html">is_prime</a>(x + y));
    [x, y] }
      </code></pre>
    </div>

    <p>It might seem as if this function merely restates the problem, rather than specifying a way to solve it. Nevertheless, this is a
      legitimate nondeterministic program.</p>

    <p>The key idea here is that expressions in a nondeterministic language can have more than one possible value. For instance,
      <code>an_element_of</code> might return any element of the given list. Our nondeterministic program will work by
      automatically choosing a possible value and keeping track of the choice. If a subsequent requirement is not met, the program
      will try a different choice, and it will keep trying new choices until the evaluation succeeds, or until we run out of choices.
      Just as lazy expressions freed the programmer from the details of how values are delayed and forced, the nondeterministic program
      will free the programmer from the details of how choices are made.</p>

    <p>To enable Slogan to support nondeterminism, we introduce a new syntactic extension called <code><span class="pw">amb</span></code>.
      The expression <code><span class="pw">amb</span> [e1, e2, ..., en]</code> will return the value of one of
      the <code>n</code> expressions <code>ei</code> <em>ambiguously</em>. For example, the expression</p>

    <div class="prog">
      <pre><code>
[<span class="pw">amb</span> [1, 2, 3], <span class="pw">amb</span> [<span class="sym">'a</span>, <span class="sym">'b</span>]]
      </code></pre>
    </div>

    <p>can have six possible values:</p>
    <div class="prog">
      <pre><code>
[1, a], [1, b], [2, a], [2, b], [3, a], [3, b]
      </code></pre>
    </div>
    
    <p><code><span class="pw">Amb</span></code> with a single choice produces an ordinary (single) value.</p>

    <p><code><span class="pw">Amb</span></code> with no choices - the expression <code><span class="pw">amb</span> []</code> - is an expression
      with no acceptable values. Operationally, we can think of it as an expression that when evaluated causes the computation to "fail":
      The computation aborts and no value is produced.</p>

    <p><code><span class="pw">Amb</span></code> can be implemented with the help of continuations, which are used to keep track of the next
      <em>choice point</em> the computation should return to. When it is first invoked, <code><span class="pw">amb</span></code> simply returns the first
      element from the list of values passed to it. It also establishes a <em>failure</em> continuation, which if invoked will restart
      the selection process with the rest of the elements in the list. This search process is allowed to continue until the list is empty, at which point
      the default failure condition is executed. In our implementation, this will raise an error.</p>
    
    <div class="prog">
      <pre><code>
<span class="kw">function</span> fail()
  <a href="ref/error.html">error</a>(<span class="str">"search tree exhausted"</span>)
      </code></pre>
    </div>

    <p>The implementation of <code><span class="pw">amb</span></code> will keep track of its next choice point by updating <code>fail</code> with
      a continuation to restart the search with the remaining values:</p>

    <div class="prog">
      <pre><code>
<span class="kw">declare</span> <span class="pw">syntax</span>
  <span class="pw">amb</span> $values
  => <a href="ref/callcc.html">callcc</a>(<span class="kw">^</span>(k)
     { <span class="kw">let</span> failed_k, fail0 = false, fail
       <span class="kw">let</span> xs = callcc(<span class="kw">^</span>(fk) { failed_k = fk; $values })
       <span class="kw">match</span> (xs)
         [] -&gt; fail()
       | [x] -&gt; { fail = fail0; k(x) }
       | y:ys -&gt; { fail = <span class="kw">^</span>() failed_k(ys); k(y) }})          
      </code></pre>
    </div>

    <p>We will also define a function that will repeat the search until a condition is met. This is the same <code>require</code> function we used in the
      <code>prime_sum_pair</code> above:</p>

    <div class="prog">
      <pre><code>
<span class="kw">function</span> require(p)
  <span class="kw">when</span>(<a href="ref/not.html">not</a>(p)) fail()
      </code></pre>
    </div>

    <p>With the primitives required for adding nondeterminism to our programs in place, we are ready to define a working version
      of the <code>prime_sum_pair</code> function:</p>

    <div class="prog">
      <pre><code>
<span class="kw">function</span> prime_sum_pair(xs, ys)
  <span class="kw">let</span> (x = <span class="pw">amb</span> xs, y = <span class="pw">amb</span> ys)
  { require(<a href="ref/is_prime.html">is_prime</a>(x + y))
    <a href="ref/list.html">list</a>(x, y) }

<span class="comment">// Usage:</span>  
prime_sum_pair([11, 12, 4, 7], [10, 3, 9, 5])
<span class="comment">// [12, 5]</span>
  
prime_sum_pair([1,2,3,4,5], [120, 100, 300, 400])
<span class="comment">// [1, 100]</span>
      </code></pre>
    </div>

    <p><b>Exercise 13.1.</b> Having <code><span class="pw">amb</span></code> as a syntactic extension clearly marks it out as doing something
      very different from a regular function call. But it is not necessary that is should be a special form recognized by the compiler. How will you
      define <code><span class="pw">amb</span></code> as a normal function?</p>

    <p><b>Exercise 13.2</b> As the argument to <code><span class="pw">amb</span></code> is a regular list, all its elements are evaluated even
      before their values may be actually required by the nondeterministic computation. How will you make sure that the expressions passed to
      <code><span class="pw">amb</span></code> will be evaluated only when they are explicitly <em>required</em>?</p>
    
    <h3>13.3.1 Solving Logic Puzzles</h3>

    <p>The following puzzle (taken from Dinesman 1968) is typical of a large class of simple logic puzzles:</p>

    <p>Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.
      Baker does not live on the top floor. Cooper does not live on the bottom floor.
      Fletcher does not live on either the top or the bottom floor.
      Miller lives on a higher floor than does Cooper.
      Smith does not live on a floor adjacent to Fletcher's.
      Fletcher does not live on a floor adjacent to Cooper's. Where does everyone live?</p>
    
    <p>We can determine who lives on each floor in a straightforward way by enumerating all the possibilities and imposing the given restrictions:</p>
    
    <div class="prog">
      <pre><code>
<span class="kw">function</span> multiple_dwelling()
  <span class="kw">let</span> (xs = [1, 2, 3, 4, 5],
       baker = <span class="pw">amb</span> xs,
       cooper = <span class="pw">amb</span> xs,
       fletcher = <span class="pw">amb</span> xs,
       miller = <span class="pw">amb</span> xs,
       smith = <span class="pw">amb</span> xs)
   { require(is_distinct([baker, cooper, fletcher, miller, smith]))
     require(baker &lt;&gt; 5)
     require(cooper &lt;&gt; 1)
     require(fletcher &lt;&gt; 5)
     require(fletcher &lt;&gt; 1)
     require(miller &gt; cooper)
     require(abs(smith - fletcher) &lt;&gt; 1)
     require(abs(fletcher - cooper) &lt;&gt; 1);
     [<span class="sym">'baker</span>:baker, <span class="sym">'cooper</span>:cooper,
      <span class="sym">'fletcher</span>:fletcher, <span class="sym">'miller</span>:miller,
      <span class="sym">'smith</span>:smith] }
      </code></pre>
    </div>

    <p>The function <code>is_distinct</code> determines if all elements in a list are unique and can be defined as,</p>
    
    <div class="prog">
      <pre><code>
<span class="kw">function</span> is_distinct(xs)
  <span class="kw">if</span> (is_empty(xs)) <span class="pw">true</span>
  <span class="kw">else if</span> (is_empty(tail(xs))) <span class="pw">true</span>
  <span class="kw">else if</span> (member(head(xs), tail(xs))) <span class="pw">false</span>
  <span class="kw">else</span> is_distinct(tail(xs))
      </code></pre>
    </div>

    <p>Calling the <code>multiple_dwelling</code> function will solve the puzzle for us:</p>

    <div class="prog">
      <pre><code>
multiple_dwelling()
<span class="comment">// [baker:3, cooper:2, fletcher:4, miller:5, smith:1]</span>
      </code></pre>
    </div>

    <p><b>Exercise 13.3</b> If you carefully read the specification of the puzzle, it will become clear that not all combinations of peoples and floors
      needs to be generated and searched. For instance, the combination of <code>baker</code> and floor <code>5</code> need not be checked as it
      is explicitly stated that he does not live on that floor. Can you write a more efficient version of <code>multiple_dwelling</code> by
      eliminating all such redundant checks?</p>

    <hr></hr>

    <div class="note">
      <p>
        <sup><a name="01"></a><a href="#01-back">1</a></sup>In the current implementation of Slogan, syntactic abstractions are visible
        only in the scope they are defined. For instance, a macro can be used only in the closure, module or namespace that it's
        defined in. New syntax or macro should ideally be defined in the global scope.
      </p>
    </div>
    <div class="note">
      <p>
        <sup><a name="02"></a><a href="#02-back">2</a></sup>This section is based mostly on content from
        <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3" target="_blank">Chapter 4.3</a> of SICP.
      </p>
    </div>

    <hr></hr>
    <p align="center">
      <a href="ex01.html">Next</a> | <a href="dist.html">Previous</a> | <a href="index.html">Contents</a>
    </p>
    
  </body>
</html>
